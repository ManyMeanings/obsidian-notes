- **Metadata**
	- Link: [零钱兑换](https://leetcode.cn/problems/coin-change/description/ "https://leetcode.cn/problems/coin-change/description/")
	- Tags : [[动态规划]]
	- Difficulty：Medium
	- Date : 2023-09-19
---
## 描述

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

## 思路

**自顶向下**

**1、确定 base case**，这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

**2、确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

**3、确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

**4、明确 `dp` 函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

**所以我们可以这样定义 `dp` 函数：`dp(n)` 表示，输入一个目标金额 `n`，返回凑出目标金额 `n` 所需的最少硬币数量**。

## 题解

```js
/**
* @param {number[]} coins
* @param {number} amount
* @return {number}
*/
var coinChange = function (coins, amount) {
    const memo = new Array(amount + 1);
    return dp(coins, memo, amount);
};

var dp = function (coins, memo, amount) {
    if (amount === 0) return 0;
    if (amount < 0) return -1;

    // 查备忘录，防止重复计算
    if (memo[amount] !== undefined) return memo[amount];

    let res = Number.MAX_VALUE;
    for (let coin of coins) {
        // 计算子问题的结果
        let subProblem = dp(coins, memo, amount - coin);
        // 子问题无解则跳过
        if (subProblem === -1) continue;
        // 在子问题中选择最优解，然后加一
        res = Math.min(res, subProblem + 1);
    }

    // 把计算结果存入备忘录
    memo[amount] = res === Number.MAX_VALUE ? -1 : res;
    return memo[amount];
};
```

```js
/**
* @param {number[]} coins
* @param {number} amount
* @return {number}
*/
var coinChange = function (coins, amount) {
    const dp = new Array(amount + 1).fill(amount + 1);
    dp[0] = 0;
    // 遍历所有状态的取值
    for (let i = 1; i < dp.length; i++) {
	    // 求所有选择的最小值 
        for (let coin of coins) {
	        // 子问题无解，跳过 
            if (i - coin < 0) continue;
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
    return dp[amount] === amount + 1 ? -1 : dp[amount];
};
```
**复杂度分析**

- 时间复杂度： `O(kn)`, `k` 是硬币种类数量，`n` 是目标金额

- 空间复杂度：