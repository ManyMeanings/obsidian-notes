### 数组和链表的遍历

单链表和数组的遍历可以是迭代的，也可以是递归的

只要是递归形式的遍历，都可以有**前序位置**和**后序位置**，分别在**递归之前**和**递归之后**。

![[Pasted image 20230825133257.png]]

```js
// 迭代遍历数组
var traverse = function(arr){
    for (var i=0; i<arr.length; i++) {
        // Code block to be executed
    }
}
// 递归遍历数组
var traverse = function(arr, i){
    if (i == arr.length) {
        return;
    }
    // 前序位置
    traverse(arr, i + 1);
    // 后序位置
}
//迭代遍历链表
var traverse = function(head){
    for (var p = head; p != null; p = p.next) {
        // Code block to be executed
    }
}
// 递归遍历链表
var traverse = function(head){
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
}

```

### 二叉树遍历

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点：**

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**

![[Pasted image 20230825133726.png]]

```js
var traverse = function(root) {
    if (root === null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}
```

### 二叉树解题的思维模式

#### 1、遍历一遍二叉树（回溯算法）

是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 `traverse` 函数配合**外部变量**来实现，这叫「遍历」的思维模式。

#### 2、分解问题计算（动态规划）

是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个**函数的返回值**，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

### 以树的视角看动归/回溯/DFS算法的区别和联系

**动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同**：

- **[[动态规划]]算法属于分解问题的思路，它的关注点在整棵「子树」**。
- **[[回溯]]算法属于遍历的思路，它的关注点在节点间的「树枝」**。
- **[[DFS]] 算法属于遍历的思路，它的关注点在单个「节点」**。