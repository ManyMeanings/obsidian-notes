**二分查找适用场景：寻找一个数、寻找左侧边界、寻找右侧边界**

**核心框架**

分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。

```js
var binarySearch = function(nums, target) {
    let left = 0, right = ...;

    while(...) {
        let mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

**细节处理**

明确**搜索区间**。根据你设定的搜索区间是左闭右开还是左闭右闭，`while` 循环终止条件是搜索区间不存在的时候，对 `mid` 的加减也是根据 `mid` 所在的索引是否已经搜索过了。

## 具体实现

**一、寻找一个数**

```js
/**
* @param {number[]} nums
* @param {number} target
* @return {number}
*/
var search = function (nums, target) {
    // 搜索区间 - [left, right] 左闭右闭
    let left = 0,
        right = nums.length - 1;

    // 当left > right时搜索区间[left, right]不存在，终止循环
    while (left <= right) {
        let mid = Math.floor(left + (right - left) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            // mid 已经搜索过了，取 [mid + 1, right] 为下一个区间
            left = mid + 1;
        } else if (nums[mid] > target) {
            // mid 已经搜索过了，取 [left, mid - 1] 为下一个区间
            right = mid - 1;
        }
    }

    return -1;
};

```

**二、寻找左侧边界**

```js
var leftBound = function(nums, target) {
    let left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right) {
        let mid = Math.floor(left + (right - left) / 2);
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 如果越界，target 肯定不存在，返回 -1
    if (left < 0 || left >= nums.length) {
        return -1;
    }
    // 判断一下 nums[left] 是不是 target
    return nums[left] === target ? left : -1;
}
```

**三、寻找右侧边界**

