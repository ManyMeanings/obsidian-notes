### 什么是三次握手 ？

![[Pasted image 20240105192202.png]]

1. 第一次握手：
	- **目的** 服务端确认客户端是否有发送能力
	- **行为** 客户端发送请求报文：SYN = 1，随机生成的序列号 =  x，进入 SYN_SENT 状态
2. 第二次握手：
	- **目的** 客户端确认服务端是否有发送和接受的能力
	- **行为** 服务端收到请求报文，由 SYN = 1 知道客户端请求建立连接，发送应答报文：SYN = 1，ACK = 1，随机生成的序列号 = y，acknowledge number = x + 1，进入 SYN_RCVD 状态
3. 第三次握手：
	- **目的** 服务端确认客户端是否有接收能力
	- **行为** 客户端收到应答报文，检查 acknowledge number 是否为 x+1，ACK 是否为 1，检查正确之后发送确认报文：ACK=1， acknowledge number = y+1，进入 ESTABLISHED 状态；服务端检查 ACK 为 1 和 acknowledge number = y+1 之后，也进入 ESTABLISHED 状态；完成三次握手，连接建立。

#### 可以改成两次握手吗？

不可以，有两个原因：
- **可能会出现已失效的连接请求报文传到服务端**，服务端会误以为客户端发起了一个新的连接请求，于是向客户端发出确认报文。此时假如只有两次握手，**服务端会以为连接已经建立了，并一直等待客户端发来数据，导致服务端的资源白白浪费**；但是有第三次握手的话，服务端会由于收不到客户端的确认停止建立连接。
- 两次握手无法保证客户端正确接收第二次握手的报文（服务端无法确认客户端是否收到），也无法保证客户端和服务端之间成功互换初始序列号。

#### 第三次握手中，如果客户端的 ACK 未送达服务端，会怎样？

服务端重发之前的 SYN+ACK（默认重发五次，之后自动关闭连接进入 CLOSED 状态），客户端收到后会重新传 ACK 给 Server。

#### 如果已经建立了连接，但客户端出现了故障怎么办？

服务端每收到一次客户端的请求后都会复位一个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 什么是四次挥手？

![[Pasted image 20240105203735.png]]

1. 第一次挥手：
	1. **目的** 客户端对服务端说：我说完了（类比打电话）
	2. **行为** Client 将 FIN 置为 1，发送一个序列号 seq 给 Server，进入 FIN_WAIT_1 状态
2. 第二次挥手：
	1. **目的** 服务端回答：我知道了，然后把还没说的话说完
	2. **行为** Server 收到 FIN 之后，发送一个 ACK=1，acknowledge number=收到的序列号 +1，进入 CLOSE_WAIT 状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。
3. 第三次挥手：
	1. **目的** 服务端对客户端说：我也说完了
	2. **行为** Server 将 FIN 置 1，发送一个序列号给 Client，进入 LAST_ACK 状态；
4. 第四次挥手：
	1. **目的** 客户端回答：我知道了，双方挂断电话
	2. **行为** Client 收到服务器的 FIN 后，进入 TIME_WAIT 状态；接着将 ACK 置 1，发送一个 acknowledge number=序列号 +1 给服务器；服务器收到后，确认 acknowledge number 后，变为 CLOSED 状态，不再向客户端发送数据。客户端等待 2MSL（报文段最长寿命）时间后，也进入 CLOSED 状态。完成四次挥手。

#### 可以改为三次挥手吗？

不能，因为：
- 没有第二次挥手：服务器收到客户端断开连接的请求时，**可能还有一些数据没有发完**，这时先回复 ACK，表示接收到了断开连接的请求。
- 没有第四次挥手：服务端不确定客户端是否知道数据已经发完就直接关闭连接，假如客户端没收到会一直等待

#### 客户端 TIME_WAIT 状态的意义是什么？

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。如果 Server 没有收到 ACK，就会重发 FIN，如果 Client 在 **2MSL** 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL（），防止 Server 没有收到 ACK 而不断重发 FIN。

MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

### TCP 如何保证传输的可靠性

1. **应答机制** 接收方收到数据之后，会发送一个确认。
2. **超时重发** 如果发送方在超时时间内未收到应答，就会重新发送数据。
3. **序列号和确认号** 对接收方来说，通过序列号可以对数据包进行**排序和去重**；对发送方来说，通过确认号可以确认**哪些数据包需要重发**
4. **流量控制** 使用滑动窗口协议来控制发送方发送数据的速度。滑动窗口的大小取决于接收方的可用缓冲区大小和网络延迟等因素，会动态调整。

### TCP 如何实现流量控制

使用**滑动窗口协议**实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回 ACK 时将接受窗口大小放在 TCP 报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。

发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的**接收能力**，拥塞窗口表明了**网络的传送能力**。

#### 接收窗口为 0 时会怎样？

如果接收方没有能力接收数据，就会将接收窗口设置为 0，这时发送方必须暂停发送数据，但是会启动一个持续计时器 (persistence timer)，**到期后发送一个大小为 1 字节的探测数据包**，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

### TCP 和 UDP 的区别？

TCP（传输控制协议）：
- **面向连接** 保证数据的可靠有序，不丢不重
- 只支持**点对点**通信
- 面向**字节流**，发送数据时以字节为单位
- 适合对**可靠性**要求高的情况：http 等

UDP（用户数据报协议）：
- **无连接** 不保证数据的可靠交付，不保证数据包的顺序，没有拥塞控制
- 支持一对一、一对多、多对一、多对多的通信
- 面向**报文**，一个报文只能一次发完
- 适合对**实时性**要求高的情况：游戏，直播等

### HTTP 协议的主要特点？

- **无连接** 每次连接只处理一个请求。服务端处理完请求并收到客户端的应答后，即断开连接。采用这种方式可以**节省传输时间**。
- **无状态** HTTP 对于事务处理没有记忆能力。不需要处理先前信息意味着**应答更快**。
- **简单快速** 客户向服务器请求服务时，只需传送请求方法和路径。
- **数据类型任意**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

### 5. HTTP 报文的组成部分

http 报文包括请求报文和响应报文。

请求报文包括：
- 请求行：包括请求方法、请求的 url、http 协议及版本。
- 请求头：一大堆的键值对。
- 空行：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。
- 请求体：数据部分。

响应报文包括：
- 状态行：http 协议及版本、状态码及状态描述。
- 响应头
- 空行
- 响应体

### HTTP 和 HTTPS 有什么区别？

1. **端口不同** HTTP 使用的是 80 端口，HTTPS 使用 443 端口；
2. **有无加密** HTTP（超文本传输协议）信息是明文传输，HTTPS 运行在 SSL(Secure Socket Layer) 之上，添加了加密和认证机制，更加安全；
3. HTTPS 由于加密解密会带来更大的 CPU 和内存开销；
4. HTTPS 通信需要证书，一般需要向证书颁发机构（CA）购买

### HTTPS 的连接过程？

1. 客户端向服务器**发起 HTTPS 请求**；
2. 服务器**将自己的身份信息以数字证书的形式发回给浏览器**。证书内容：网站地址，**加密公钥**（用于非对称加密），以及证书的颁发机构等信息；
3. **客户端对数字证书进行验证**。包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；
4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个用于对称加密的**随机密钥**，并用服务器提供的公钥对其进行加密；使用 Hash 算法（HASH 算法用于验证数据的完整性）对握手消息进行**摘要**计算，并对摘要使用之前产生的密钥加密；**将加密后的随机密钥和摘要一起发送给服务器**；
5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出 Hash 摘要值，并验证握手消息是否一致；如果一致，**服务器使用对称加密的密钥加密握手消息发给浏览器**；
6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密

#### 什么是对称加密、非对称加密？区别是什么？

- **对称加密** 加密和解密使用同一个密钥
- **非对称加密** 有两个密钥：公钥和私钥。用公钥加密的数据需要用私钥来解密。（RSA）
- **区别** 对称加密速度快；非对称加密安全性高

#### HTTPS 连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？

1. 通过证书验证域名、有效期等信息
2. 判断证书来源合法性：通过本地存储的权威机构根证书进行验证
3. 判断证书是否被篡改：通过 CA 服务器校验
4. 判断证书是否已吊销：通过 CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）

#### 数字签名为什么可信？

发送者 A 用私钥进行签名，接收者 B 用公钥验证签名。因为除 A 外没有人有私钥，所以 B 相信签名是来自 A。A 不可抵赖，B 也不能伪造报文。

### GET 与 POST 的区别？

- **浏览器回退** get 不会重新请求， post 会重新请求
- **缓存** get 请求会被浏览器主动缓存， post 不会
- **安全性** get 请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在 URL 中。post 的参数不会被保存，安全性相对较高；
- **长度限制** GET 的长度有限制（基本是 2kb），而 POST 数据无限制
- **数据类型** GET 只允许 ASCII 字符，POST 对数据类型没有要求，也允许二进制数据

### Session 与 Cookie 的区别？

Session 是服务器端保持状态的方案，Cookie 是客户端保持状态的方案

- Cookie 保存在客户端本地，客户端请求服务器时会将 Cookie 一起提交；
- Session 保存在服务端，通过检索 Sessionid 查看状态。保存 Sessionid 的方式可以采用 Cookie（如果禁用了 Cookie，可以把会话 ID 保存在 URL 中）。

### 从输入网址到获得页面的过程 ？

1. **URL 解析**判断输入的是合法的 URL 还是待搜索的关键词，根据输入的内容进行自动完成，安全检查等操作。
2. **浏览器缓存** 浏览器查看有无缓存，如果有缓存是否在有效期内，不满足则进入下一步。
3. **DNS 查询** 浏览器缓存 -> 操作系统缓存 -> 本地 host 文件 -> 通过本地 DNS 服务器进行查询（如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；）
4. **建立连接** 通过三次握手建立 TCP 连接并发送 http 请求。
5. **处理请求** 服务器收到请求后交给后台程序处理，根据请求格式返回对应的资源。
6. **渲染页面** 浏览器根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSS 规则树，然后根据它们来构建渲染树，根据渲染树来进行布局。布局完成后，使用浏览器的 UI 接口对页面进行绘制。同时根据配置加载和运行 js 脚本。

### HTTP 请求有哪些常见状态码？

1. **1xx 状态码：请求正在处理**
	1. `100 Continue` 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
2. **2xx 状态码：操作成功**
	1. `200 OK` 正常返回信息
	2. `201 Created` 请求成功并且服务器创建了新的资源
	3. `204 No Content` 不含响应体
	4. `206 Partial Content` 数据较大时进行分片传输
3. **3xx 状态码：重定向**
	1. `301 Moved Permanently` 永久重定向
	2. `302 Found` 临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET
	3. `304 Not Modified` 自上次请求未修改，资源已被缓存
	4. `307 Temporary Redirect` 临时重定向，在重定向时不会改变 method
4. **4xx 状态码：客户端错误**
	1. `400 Bad Request` 请求格式错误
	2. `401 Unauthorized` 请求未授权
	3. `403 Forbidden` 禁止访问
	4. `404 Not Found` 找不到如何与 URI 相匹配的资源
5. **5xx 状态码：服务端错误**
	1. `500 Internal Server Error` 服务器端的未知错误
	2. `502 Bad Gateway` 应用层服务 (Java/Go/PHP) 挂了，网关层 (Nginx) 无法接收到响应
	3. `503 Service Unavailable` 服务器端暂时无法处理请求（可能是过载或维护）
	4. `504 Gateway Timeout` 应用层服务超时，超过了 Nginx 配置的超时时间

###  http 的缓存机制？

- **强缓存** 浏览器直接读本地缓存，不会再跟服务器端交互，状态码 200。由 `Cache-Control`，`Exipres` 控制。
- **协商缓存** 每次请求需要让服务器判断一下资源是否更新过，从而决定浏览器是否使用缓存，如果是，则返回 304，否则重新完整响应。由 `Last-Modified` / `IfModified-Since`， `Etag` /`If-None-Match` 实现。

#### 介绍一下和缓存相关的响应头/请求头？

- **强缓存**
	- `Expires` 资源过期的绝对时间
	- `Cache-Control`
		- `no-cache` 不使用强缓存，需要与服务器验协商缓存验证
		- `no-store` 不使用任何缓存
		- `max-age=<seconds>` 缓存存储的最大周期（优先级高于 Expires）
- **协商缓存**
	- `Etag` 服务器为每份资源生成的**唯一标识**。在浏览器发起请求，浏览器的请求报文头会包含 `If-None-Match` 字段，其值为上次返回的 `Etag` 发送给服务器，服务器接收到次报文后发现 `If-None-Match` 则与被请求资源的唯一标识进行对比。如果相同说明资源没有修改，则响应返 304，浏览器直接从缓存中获取数据信息。如果不同则说明资源被改动过，则响应整个资源内容，返回状态码 200。
	- `Last-Modified` 资源的最后修改时间，服务端返回，客户端发起请求时会带上。服务端收到此请求头发现有 `if-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。如果已经修改，那么开始传输响应一个整体，服务器返回：200 OK

#### 现代前端应用应如何配置 HTTP 缓存机制？

- 文件路径中带有 hash 值，设置一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 `Cache-Control: public,max-age=31536000,immutable`
- 文件路径中不带有 hash 值：协商缓存。大部分为 `public` 下文件。配置响应头 `Cache-Control: no-cache` 与 `etag/last-modified`
