### 什么是三次握手 ？

![[Pasted image 20240105192202.png]]

三次握手 (Three-way Handshake) 其实就是指建立一个 TCP 连接时， 需要客户端和服务器总共发送 3 个包。主要作用就是为了确认双方的接收能力和发送能力是否正常、互换双方的初始化序列号为后面的可靠性传送做准备。

握手开始时客户端处于 Closed 的状态，服务端处于 Listen 状态。
1. 第一次握手 (SYN=1, seq=x)：
	- **目的** 服务端确认客户端是否有发送能力
	- **行为** 建立连接。客户端发送连接请求报文段，这是报文首部中的同步位 SYN=1，同时选择一个初始序列号 seq=x ，此时，客户端进程进入了 SYN-SENT（同步已发送状态）状态。（TCP 规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号）
2. 第二次握手 (SYN=1, ACK=1, seq=y, ACKnum=x+1)：
	- **目的** 客户端确认服务端是否有发送和接受的能力
	- **行为** 服务器收到客户端的 SYN 报文段，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号 ACKnum=x+1，同时，自己还要发送 SYN 请求信息，SYN=1，为自己初始化一个序列号 seq=y，服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。（这个报文也不能携带数据，但是同样要消耗一个序号）
3. 第三次握手 (ACK=1，ACKnum=y+1)：
	- **目的** 服务端确认客户端是否有接收能力
	- **行为** - 客户端收到服务器的 SYN+ACK 报文段，再次发送确认包 (ACK)，SYN 标志位为 0，ACK 标志位为 1，确认号 ACKnum = y+1，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED（已建立连接）状态，完成 TCP 三次握手

#### 可以改成两次握手吗？

不可以，有两个原因：
- **可能会出现已失效的连接请求报文传到服务端**，服务端会误以为客户端发起了一个新的连接请求，于是向客户端发出确认报文。此时假如只有两次握手，**服务端会以为连接已经建立了，并一直等待客户端发来数据，导致服务端的资源白白浪费**；但是有第三次握手的话，服务端会由于收不到客户端的确认停止建立连接。
- 两次握手无法保证客户端正确接收第二次握手的报文（服务端无法确认客户端是否收到），也无法保证客户端和服务端之间成功互换初始序列号。

#### 第三次握手中，如果客户端的 ACK 未送达服务端，会怎样？

服务端重发之前的 SYN+ACK（默认重发五次，之后自动关闭连接进入 CLOSED 状态），客户端收到后会重新传 ACK 给 Server。

#### 如果已经建立了连接，但客户端出现了故障怎么办？

服务端每收到一次客户端的请求后都会复位一个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 什么是四次挥手？

![[Pasted image 20240105203735.png]]

1. 第一次挥手 (FIN=1，seq=x)：
	1. **目的** 客户端对服务端说：我说完了（类比打电话）
	2. **行为** 主机 1（可以是客户端，也可以是服务器端），设置 seq=x，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；
2. 第二次挥手 (ACK=1，ACKnum=x+1)：
	1. **目的** 服务端回答：我知道了，然后把还没说的话说完
	2. **行为** 主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknnum=x+1，主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；
3. 第三次挥手 (FIN=1，seq=y)：
	1. **目的** 服务端对客户端说：我也说完了
	2. **行为** 主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态
4. 第四次挥手 (ACK=1，ACKnum=y+1)：
	1. **目的** 客户端回答：我知道了，双方挂断电话
	2. **行为** 主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了，进入 CLOSED 状态。（主机 1 等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。）

#### 可以改为三次挥手吗？

不能，因为 TCP 的连接是全双工的，所以需要 双方分别释放到对方的连接，单独一方的连接释放，只代表不能向对方发送数据，连接处于的是半释放的状态。

#### 客户端 TIME_WAIT 状态的意义是什么？

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。如果 Server 没有收到 ACK，就会重发 FIN，如果 Client 在 **2MSL** 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

### TCP 如何保证传输的可靠性

1. **应答机制** 接收方收到数据之后，会发送一个确认。
2. **超时重发** 如果发送方在超时时间内未收到应答，就会重新发送数据。
3. **序列号和确认号** 对接收方来说，通过序列号可以对数据包进行**排序和去重**；对发送方来说，通过确认号可以确认**哪些数据包需要重发**
4. **流量控制** 使用滑动窗口协议来控制发送方发送数据的速度。滑动窗口的大小取决于接收方的可用缓冲区大小和网络延迟等因素，会动态调整。

### TCP 如何实现流量控制

使用**滑动窗口协议**实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回 ACK 时将接受窗口大小放在 TCP 报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。

发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的**接收能力**，拥塞窗口表明了**网络的传送能力**。

#### 接收窗口为 0 时会怎样？

如果接收方没有能力接收数据，就会将接收窗口设置为 0，这时发送方必须暂停发送数据，但是会启动一个持续计时器 (persistence timer)，**到期后发送一个大小为 1 字节的探测数据包**，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

### TCP 和 UDP 的区别？

TCP（传输控制协议）：
- **面向连接** 保证数据的可靠有序，不丢不重
- 只支持**点对点**通信
- 面向**字节流**，发送数据时以字节为单位
- 适合对**可靠性**要求高的情况：http 等

UDP（用户数据报协议）：
- **无连接** 不保证数据的可靠交付，不保证数据包的顺序，没有拥塞控制
- 支持一对一、一对多、多对一、多对多的通信
- 面向**报文**，一个报文只能一次发完
- 适合对**实时性**要求高的情况：游戏，直播等

### 从输入网址到获得页面的过程 ？

1. **URL 解析**判断输入的是合法的 URL 还是待搜索的关键词，根据输入的内容进行自动完成，安全检查等操作。
2. **浏览器缓存** 浏览器查看有无缓存，如果有缓存是否在有效期内，不满足则进入下一步。
3. **DNS 查询** 浏览器缓存 -> 操作系统缓存 -> 本地 host 文件 -> 通过本地 DNS 服务器进行查询（如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；）
4. **建立连接** 通过三次握手建立 TCP 连接并发送 http 请求。
5. **处理请求** 服务器收到请求后交给后台程序处理，根据请求格式返回对应的资源。
6. **渲染页面** 浏览器根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSS 规则树，然后根据它们来构建渲染树，根据渲染树来进行布局。布局完成后，使用浏览器的 UI 接口对页面进行绘制。同时根据配置加载和运行 js 脚本。

#### DNS 查询的完整过程（www.baidu.com）？

1. 查找**浏览器缓存**中有无对应的 IP 地址
2. 把请求发送给本地 DNS 服务器，在**本地域名服务器缓存**中查询有无对应的 IP 地址
3. 本地 DNS 服务器向**根域名服务器**发送请求，根域名服务器会返回所查询域（.com）的顶级域名服务器地址列表
4. 本地 DNS 服务器向其中一个**顶级域名服务器**发送请求，接受请求的服务器查询自己的**缓存**，如果有记录，就返回查询结果，如果没有就返回相关的**下一级**的权威域名（.baidu）服务器的地址列表
5. 本地 DNS 服务器向其中一个权威域名（.baidu）服务器发送请求，域名服务器返回对应的结果
6. 本地 DNS 服务器将返回结果**保存在缓存**中，便于下次使用

### HTTP 协议的主要特点？

- **无连接** 每次连接只处理一个请求。服务端处理完请求并收到客户端的应答后，即断开连接。采用这种方式可以**节省传输时间**。
- **无状态** HTTP 对于事务处理没有记忆能力。不需要处理先前信息意味着**应答更快**。
- **简单快速** 客户向服务器请求服务时，只需传送请求方法和路径。
- **数据类型任意**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

### HTTP 报文的组成部分

**请求报文**：
- 请求行：包括请求方法、请求的 url、http 协议及版本。
- 请求头：一大堆的键值对。
- 空行：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。
- 请求体：数据部分。
**响应报文**：
- 状态行：http 协议及版本、状态码及状态描述。
- 响应头
- 空行
- 响应体

#### 常见的 HTTP 请求头和响应头？

**请求头**
- `Accept`: 浏览器能够处理的内容类型
- `Accept-Charset`: 浏览器能够显示的字符集
- `Accept-Encoding`: 浏览器能够处理的压缩编码
- `Accept-Language`: 浏览器当前设置的语言
- `Connection`: 浏览器与服务器之间连接的类型
- `Cookie`: 当前页面设置的任何 Cookie
- `Host`: 发出请求的页面所在的域
- `Referer`: 发出请求的页面的 URL
- `User-Agent`: 浏览器的用户代理字符串
**响应头**
- `Date`: 表示消息发送的时间，时间的描述格式由 rfc822 定义
- `server`: 服务器名称
- `Connection`: 浏览器与服务器之间连接的类型
- `Cache-Control`: 控制 HTTP 缓存
- `content-type`: 表示后面的文档属于什么 MIME 类型
	- `application/x-www-form-urlencoded`: 浏览器的原生 form 表单，如果不设置 `enctype` 属性，那么最终就会以这种格式提交。提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。
	- `multipart/form-data`: 该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。
	- `application/json`: 服务器消息主体是序列化后的 JSON 字符串。
	- `text/xml`: 该种方式主要用来提交 XML 格式的数据。

### HTTP 1.1 和 HTTP 2.0 的区别？

- **二进制协议** HTTP/1.1 报文的头信息必须是文本 (ASCII 编码)，数据体可以是文本或二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制。
- **多路复用** HTTP/2 仍然复用 TCP 连接， 但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应， 而且不用按照顺序一一发送，这样就避免了 " 队头堵塞 " 的问题。
- **数据流** HTTP/2 将每个请求或回应的所有数据包称为一个数据流，每个数据流都有一个 独一无二的编号
- **头信息压缩** HTTP/2 的头信息使用 gzip 或 compress 压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成对应的索引号，以后就只发送索引号，减少重复字段的体积。
- **服务器推送** HTTP/2 允许服务器未经请求，主动向客户端发送静态资源

#### 说一下 HTTP 3.0

HTTP/3 基于 UDP 协议实现了类似于 TCP 的多路复用数据流、传输可靠性等功能，这套功能被称为 QUIC 协议。

### HTTP 和 HTTPS 有什么区别？

1. **端口不同** HTTP 使用的是 80 端口，HTTPS 使用 443 端口；
2. **有无加密** HTTP（超文本传输协议）信息是明文传输，HTTPS 运行在 SSL(Secure Socket Layer) 之上，添加了加密和认证机制，更加安全；
3. HTTPS 由于加密解密会带来更大的 CPU 和内存开销；
4. HTTPS 通信需要证书，一般需要向证书颁发机构（CA）购买

### HTTPS 的连接过程？

1. 客户端向服务器**发起 HTTPS 请求**，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 服务器收到请求后，确认双方使用的加密方法，**将自己的身份信息以数字证书的形式发回给浏览器**。证书内容：网站地址，**加密公钥**（用于非对称加密），以及证书的颁发机构等信息；
3. **客户端对数字证书进行验证**。包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；
4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个用于对称加密的**随机密钥**，并用服务器提供的公钥对其进行加密；使用 Hash 算法（HASH 算法用于验证数据的完整性）对握手消息进行**摘要**计算，并对摘要使用之前产生的密钥加密；**将加密后的随机密钥和摘要一起发送给服务器**；
5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出 Hash 摘要值，并验证握手消息是否一致；如果一致，**服务器使用对称加密的密钥加密握手消息发给浏览器**；
6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密

#### 什么是对称加密、非对称加密？区别是什么？

- **对称加密** 加密和解密使用同一个密钥
- **非对称加密** 有两个密钥：公钥和私钥。用公钥加密的数据需要用私钥来解密。（RSA）
- **区别** 对称加密速度快；非对称加密安全性高

#### HTTPS 连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？

1. 通过证书验证域名、有效期等信息
2. 判断证书来源合法性：通过本地存储的权威机构根证书进行验证
3. 判断证书是否被篡改：通过 CA 服务器校验
4. 判断证书是否已吊销：通过 CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）

#### 数字签名为什么可信？

发送者 A 用私钥进行签名，接收者 B 用公钥验证签名。因为除 A 外没有人有私钥，所以 B 相信签名是来自 A。A 不可抵赖，B 也不能伪造报文。

### 常见的 HTTP 请求方法？

- GET: 向服务器获取数据;
- POST: 将实体提交到指定的资源，通常会造成服务器资源的修改;
- PUT: 上传文件，更新数据;
- DELETE: 删除服务器上的对象;
- HEAD: 获取报文首部，与 GET 相比，不返回报文主体部分;
- OPTIONS: 询问支持的请求方法，用来跨域请求;
- CONNECT: 要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信;
- TRACE: 回显服务器收到的请求，主要用于测试或诊断。

#### GET 与 POST 的区别？

- **应用场景** get 请求是一个幂等的请求，用于对服务器资源不产生影响的场景；post 与之相反
- **是否缓存** get 请求会被浏览器主动缓存， post 不会
- **安全性** get 的请求参数明文出现在 URL ，会被保留在历史记录中；post 的参数在请求报文的实体里，不会被浏览器保存；
- **浏览器回退** get 不会重新请求， post 会重新请求
- **长度限制** GET 的长度有限制（基本是 2kb），而 POST 数据无限制
- **参数类型** GET 只允许 ASCII 字符，POST 对数据类型没有要求，也允许二进制数据

#### POST 和 PUT 的区别？

- PUT 请求是**更新数据**，不会增加数据的种类
- POST 请求是向服务器端发送数据，它会**创建新的内容**

### HTTP 请求有哪些常见状态码？

1. **1xx 状态码：请求正在处理**
	1. `100 Continue` 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
2. **2xx 状态码：操作成功**
	1. `200 OK` 正常返回信息
	2. `201 Created` 请求成功并且服务器创建了新的资源
	3. `204 No Content` 不含响应体
	4. `206 Partial Content` 数据较大时进行分片传输
3. **3xx 状态码：重定向**
	1. `301 Moved Permanently` 永久重定向
	2. `302 Found` 临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET
	3. `304 Not Modified` 自上次请求未修改，资源已被缓存
	4. `307 Temporary Redirect` 临时重定向，在重定向时不会改变 method
4. **4xx 状态码：客户端错误**
	1. `400 Bad Request` 请求格式错误
	2. `401 Unauthorized` 请求未授权
	3. `403 Forbidden` 禁止访问
	4. `404 Not Found` 找不到如何与 URI 相匹配的资源
5. **5xx 状态码：服务端错误**
	1. `500 Internal Server Error` 服务器端的未知错误
	2. `502 Bad Gateway` 应用层服务 (Java/Go/PHP) 挂了，网关层 (Nginx) 无法接收到响应
	3. `503 Service Unavailable` 服务器端暂时无法处理请求（可能是过载或维护）
	4. `504 Gateway Timeout` 应用层服务超时，超过了 Nginx 配置的超时时间

###  http 的缓存机制？

- **强缓存** 浏览器直接读本地缓存，不会再跟服务器端交互，状态码 200。由 `Cache-Control`，`Exipres` 控制。
- **协商缓存** 每次请求需要让服务器判断一下资源是否更新过，从而决定浏览器是否使用缓存，如果是，则返回 304，否则重新完整响应。由 `Last-Modified` / `IfModified-Since`， `Etag` /`If-None-Match` 实现。

#### 介绍一下和缓存相关的响应头/请求头？

- **强缓存**
	- `Expires` 资源过期的绝对时间
	- `Cache-Control`
		- `no-cache` 不使用强缓存，需要与服务器验协商缓存验证
		- `no-store` 不使用任何缓存
		- `max-age=<seconds>` 缓存存储的最大周期（优先级高于 Expires）
- **协商缓存**
	- `Etag` 服务器为每份资源生成的**唯一标识**。在浏览器发起请求，浏览器的请求报文头会包含 `If-None-Match` 字段，其值为上次返回的 `Etag` 发送给服务器，服务器接收到次报文后发现 `If-None-Match` 则与被请求资源的唯一标识进行对比。如果相同说明资源没有修改，则响应返 304，浏览器直接从缓存中获取数据信息。如果不同则说明资源被改动过，则响应整个资源内容，返回状态码 200。
	- `Last-Modified` 资源的最后修改时间，服务端返回，客户端发起请求时会带上。服务端收到此请求头发现有 `if-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。如果已经修改，那么开始传输响应一个整体，服务器返回：200 OK

#### 现代前端应用应如何配置 HTTP 缓存机制？

- 静态资源文件路径中带有 hash 值，设置一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 `Cache-Control: public,max-age=31536000,immutable`
- 文件路径中不带有 hash 值：协商缓存。大部分为 `public` 下文件。配置响应头 `Cache-Control: no-cache` 与 `etag/last-modified`

### Cookie 有哪些字段？

- Domain
- Path
- Expire/MaxAge：如果未设置，则 cookie 的有效时间为会话时间。
- HttpOnly: 是否允许被 JavaScript 操作
- Secure: 只能在 HTTPS 连接中配置
- SameSite：
	- None: 任何情况下都会向第三方网站请求发送 Cookie
	- Lax: 只有导航到第三方网站的 Get 链接会发送 Cookie，跨域的图片、iframe、form 表单都不会发送 Cookie
	- Strict: 任何情况下都不会向第三方网站请求发送 Cookie

#### Cookie 的增删改查操作

```js
// 获取
document.cookie // ''

// 修改/新增
document.cookie = 'a=3'

// 删除
// 把该字段的 max-age 设置为 -1
document.cookie = 'a=3; max-age=-1'
```

#### Session 与 Cookie 的区别？

Session 是服务器端保持状态的方案，Cookie 是客户端保持状态的方案

- Cookie 保存在客户端本地，客户端请求服务器时会将 Cookie 一起提交；
- Session 保存在服务端，通过检索 Sessionid 查看状态。保存 Sessionid 的方式可以采用 Cookie（如果禁用了 Cookie，可以把会话 ID 保存在 URL 中）。

### 什么是 CDN 服务？

CDN 是内容分发网络，源站提供内容，CDN 节点进行内容分发，用户可以就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

#### CDN 原理？

1. 对于点击的数据的 URL，经过本地 DNS 系统的解析，发现该 URL 对应的是一个 CDN 专用的 DNS 服务器，DNS 系统就会将域名解析权交给 CNAME 指向的 CDN 专用的 DNS 服务器。
2. CDN 专用 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回给用户
3. 用户向 CDN 的全局负载均衡设备发起数据请求
4. CDN 的全局负载均衡设备根据用户的 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求
5. 区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的 IP 地址返回给全局负载均衡设备
6. 全局负载均衡设备把服务器的 IP 地址返回给用户
7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。

#### 什么是回源？

当有用户访问某㇐个 URL 的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问， 那么 CDN 节点不会主动去源站拿的。回源的策略间接决定了缓存的命中率，频繁回源会对源站产生较大的负担。

### 如何实现 jwt 鉴权机制？说说你的思路

JWT（JSON Web Token），本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的信息。

在目前前后端分离的开发过程中，使用 `token` 鉴权机制用于身份验证是最常见的方案，流程如下：
- 服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证
- 后续访问会根据这个令牌判断用户时候有权限进行访问

在前端接收到 `token` 后，一般情况会通过 `localStorage` 进行缓存，然后将 `token` 放到 `HTTP` 请求头 `Authorization` 中，关于 `Authorization` 的设置，前面要加上 Bearer ，注意后面带有空格

```js
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  config.headers.common['Authorization'] = 'Bearer ' + token; // 留意这里的 Authorization
  return config;
})
```
