## DOM

### 如何实现一个元素的水平垂直居中?

```css
/*绝对定位*/
.item {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/*flex*/
.container { 
  display: flex; 
  justify-content: center; 
  align-items: center;
}

/*grid*/
.container { 
  display: grid; 
  place-items: center;
}
```

### 左侧固定、右侧自适应

```css
/*grid*/
.container {
  display: grid;
  grid-template-columns: 200px 1fr;
}

/*flex*/
.container {
  display: flex;
}
.left {
  flex: 0 0 200px;
}
.main {
  flex: 1 1;
}
```

### 三栏均分布局

```css
/*grid*/
.grid-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
}
/*flex*/
.flex-container {
  display: flex;
}
.item {
  flex: 1 1 0; 
  /* flex: 0 0 calc(100% / 3);*/
}
```

### 如何实现固定长宽比的元素？

```css
#box {
  width: 200px;
  background: #9af;
  aspect-ratio: 1/2;
}

/*过去的写法*/
#box {
  padding-top: 20%; /*以父元素宽度为基准*/
  padding-left: 40%;
  background: #9af;
}
```

### 如何实现单行/多行文本溢出的省略？

```css
p {
  overflow: hidden; /*文字长度超出限定宽度，则隐藏超出的内容*/
  text-overflow: ellipsis; /*当文本溢出时，显示省略符号来代表被修剪的文本*/
  white-space: nowrap; /*设置文字在一行显示，不能换行*/
}
```

```css
.demo {
	position: relative;
	line-height: 20px;
	height: 40px;
	overflow: hidden;
}
.demo::after {
	content: "...";
	position: absolute;
	bottom: 0;
	right: 0;
	padding: 0 20px 0 10px;
}
```

### 画一个三角形

```css
.triangle {
    width: 0;
    border: 50px solid transparent; /*边框颜色为透明*/
    border-left-color: 50px solid blue; /*左三角形*/
  }
```

### 图片懒加载

**方案一:clientHeight、scrollTop 和 offsetTop**

首先给图片一个占位资源:

```html
<img src="default.jpg" data-src="http://www.xxx.com/target.jpg" />
```

接着，通过监听 scroll 事件来判断图片是否到达视口:

```js
let img = document.getElementsByTagName("img");
let num = img.length;
let count = 0;//计数器，从第一张图片开始计

lazyload();//首次加载别忘了显示图片

window.addEventListener('scroll', lazyload);

function lazyload() {
  let viewHeight = document.documentElement.clientHeight;//视口高度
  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条卷去的高度
  for(let i = count; i <num; i++) {
    // 元素现在已经出现在视口中
    if(img[i].offsetTop < scrollHeight + viewHeight) {
      if(img[i].getAttribute("src") !== "default.jpg") continue;
      img[i].src = img[i].getAttribute("data-src");
      count ++;
    }
  }
}
```

当然，最好对 scroll 事件做节流处理，以免频繁触发:

```js
// throttle函数我们上节已经实现
window.addEventListener('scroll', throttle(lazyload, 200));
```

**方案二：getBoundingClientRect**

现在我们用另外一种方式来判断图片是否出现在了当前视口, 即 DOM 元素的 getBoundingClientRect API。

上述的 lazyload 函数改成下面这样:

```js
function lazyload() {
  for(let i = count; i <num; i++) {
    // 元素现在已经出现在视口中
    if(img[i].getBoundingClientRect().top < document.documentElement.clientHeight) {
      if(img[i].getAttribute("src") !== "default.jpg") continue;
      img[i].src = img[i].getAttribute("data-src");
      count ++;
    }
  }
}
```

**方案三: IntersectionObserver**

这是浏览器内置的一个 API，实现了监听 window 的 scroll 事件、判断是否在视口中以及节流三大功能。

```js
let img = document.getElementsByTagName("img");

const observer = new IntersectionObserver(changes => {
  //changes 是被观察的元素集合
  for(let i = 0, len = changes.length; i < len; i++) {
    let change = changes[i];
    // 通过这个属性判断是否在视口中
    if(change.isIntersecting) {
      const imgElement = change.target;
      imgElement.src = imgElement.getAttribute("data-src");
      observer.unobserve(imgElement);
    }
  }
})
Array.from(img).forEach(item => observer.observe(item));
```

## JavaScript 基础

### 手写 call

```js
Function.prototype.myCall = function (context, ...args) {
  // 避免属性冲突	
  const fn = Symbol("fn");
  // 如果 context 未传入则设置为 window
  context = context || window;
  // 将调用函数临时设置为 context 的方法
  context[fn] = this;
  // 调用函数取得结果
  const result = context[fn](...args);
  // 删除方法
  delete context[fn];
  // 返回调用结果
  return result;
};
```

```js
function f(...args) {
  console.log(this.a, ...args);
}
f.myCall({ a: 1 }, 2, 3) // -> 1 2 3
```

### 手写 bind

```js
Function.prototype.myBind = function (context, ...args) {
  return (...rest) => this.call(context, ...args, ...rest);
};
// 还可以考虑用 new 调用的情况，此时 this 为 new Fn() 创建的实例
// context 替换为 this instanceof Fn ? this : context,
```

```js
function f(...args) {
  console.log(this.a, ...args);
}
f.myBind({ a: 1 }, 2)(3); // -> 1 2 3
```

### 手写 new

```js
function myNew(constructor, ...args) {
  // 1) 创建一个新对象，它的原型指向构造函数的原型对象
  const obj = Object.create(constructor.prototype);
  // 2) 执行构造函数，并将 this 指向新对象
  const result = constructor.apply(obj, args);
  // 3) 如果构造函数返回一个对象，则返回这个对象，否则返回新对象
  return result instanceof Object ? result : obj
}
```

```js
function Fn(arg) {
  this.arg = arg;
}
Fn.prototype.print = function () {
  console.log(this.arg);
};
const fn = myNew(Fn, "test");
fn.print(); // -> test
```

### 手写 Object.create

```js
function createObject(proto) {
  // 创建一个空的函数F
  function F() {}
  // 将 proto 设置为F的原型
  F.prototype = proto;
  // 返回一个新的 F 实例，新实例的原型就指向了 proto
  return new F();
}
```

```js
const proto = { arg: 'test' }
const obj = createObject(proto)
console.log(obj.arg) // -> test
```

### 手写 instanceof

```js
function myInstanceOf(obj, constructor) {
  // 对于左侧参数如果是非对象直接返回false
  if (Object(obj) !== obj) return false;
  // 对于右侧参数可以认为只能为函数且不能没有Prototype属性
  if (typeof constructor !== "function" || !constructor.prototype)
    return false;
  // 获取对象的原型
  let proto = Object.getPrototypeOf(obj);
  
  // 遍历原型链
  while (proto !== null) {
    if (proto === constructor.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  
  return false;
}
```

```js
console.log(myInstanceof([], Array)) // true
console.log(myInstanceof({}, Array)) // false
```

### 手写 Promise

**executor 与三个状态**

- `new Promise` 时，需要传递一个 `executor` 执行器函数，在构造函数中，**执行器函数立刻执行**
- `executor` 执行函数接受两个参数，分别是 `resolve` 和 `reject`
- `Promise` 只能从 `pending` 到 `rejected`, 或者从 `pending` 到 `fulfilled`
- `Promise` 的状态一旦确认，状态就凝固了，不再改变

**then 方法**

- 所有的 `Promise` 都有 `then` 方法，`then` 接收两个参数，分别是 `Promise` 成功的回调 `onFulfilled`，和失败的回调 `onRejected`
- 如果调用 `then` 时，`Promise` 已经成功，则执行 `onFulfilled`，并将 `Promise` 的值作为参数传递进去；如果 `Promise` 已经失败，那么执行 `onRejected`，并将 `Promise` 失败的原因作为参数传递进去；如果 `Promise` 的状态是 `pending`，需要将 `onFulfilled` 和 `onRejected` 函数存放起来，等待状态确定后，再依次将对应的函数执行 (观察者模式)
- `then` 的参数 `onFulfilled` 和 `onRejected` 可以不传，`Promise` **可以进行值穿透**。

**链式调用并处理 then 返回值**

- `Promise` 可以 `then` 多次，`Promise` 的 `then` 方法返回一个新的 `Promise`。
- 如果 `then` 返回的是一个正常值，那么就会把这个结果（`value`）作为参数，传递给下一个 `then` 的成功的回调（`onFulfilled`）
- 如果 `then` 中抛出了异常，那么就会把这个异常（`reason`）作为参数，传递给下一个 `then` 的失败的回调 (`onRejected`)
- 如果 `then` 返回的是一个 `promise` 或者其他 `thenable` 对象，那么需要等这个 `promise` 执行完，`promise` 如果成功，就走下一个 `then` 的成功回调；如果失败，就走下一个 `then` 的失败回调。

```js
class MyPromise {
  static PENDING = 'pending'
  static FULFILLED = 'fulfilled'
  static REJECTED = 'rejected'
  
  constructor(executor) {
    this.state = MyPromise.PENDING // 状态
    this.value = null // 结果
    this.onResolvedCallbacks = [] // 成功回调数组
    this.onRejectedCallbacks = [] // 失败回调数组

    const resolve = value => {
      // 只在 pending 状态下执行
      if (this.state === MyPromise.PENDING) {
        this.state = MyPromise.FULFILLED
        this.value = value
        this.onResolvedCallbacks.forEach(callback => callback(value))
      }
    }

    const reject = reason => {
	  // 只在 pending 状态下执行
      if (this.state === MyPromise.PENDING) {
        this.state = MyPromise.REJECTED
        this.value = reason
        this.onRejectedCallbacks.forEach(callback => callback(reason))
      }
    }

    try {
      executor(resolve, reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onResolved, onRejected) {
    // 判断参数是否是函数，否则进行值透传
    onResolved = typeof onResolved === 'function' ? onResolved : value => value
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : reason => {
            throw reason
          }

	// 链调用，需要返回一个 promise
    const promise = new MyPromise((resolve, reject) => {
      // 调用回调函数得到 then 的返回结果，如果是 promise 需要等待
      const handle = (callback, state) => {
        try {
          const result = callback(this.value)
          if (result instanceof MyPromise) {
            result.then(resolve, reject)
          } else {
            state(result)
          }
        } catch (error) {
          reject(error)
        }
      }

	  // 如果状态已改变，调用 handle 处理结果
	  // 如果状态是 pending，将 handle 推入对应的回调函数数组中
      if (this.state === MyPromise.FULFILLED) {
        setTimeout(() => handle(onResolved, resolve), 0)
      } else if (this.state === MyPromise.REJECTED) {
        setTimeout(() => handle(onRejected, reject), 0)
      } else {
        this.onResolvedCallbacks.push(() => handle(onResolved, resolve))
        this.onRejectedCallbacks.push(() => handle(onRejected, reject))
      }
    })

    return promise
  }

  catch(onRejected) {
    return this.then(null, onRejected)
  }
  finally(fn) {
    return this.then(fn, fn)
  }

  static resolve(value) {
    return new MyPromise(resolve => resolve(value))
  }

  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason))
  }
}
```

#### Promise.all

```js
Promise._all = function (promises) {
  return new Promise((resolve, reject) => {
    if (promises === null || typeof promises[Symbol.iterator] !== 'function') {
      throw new TypeError(`${promises} is not a iterable`)
    }
    promises = [...promises]
    const len = promises.length
    if (len === 0) {
      resolve([])
    }

    let count = 0
    let result = []

    for (let i = 0; i < len; i++) {
      Promise.resolve(promises[i])
        .then(res => {
          result[i] = res
          if (++count === len) {
            resolve(result)
          }
        })
        .catch(reject)
    }
  })
}
```

```js
function test() {
  try {
    Promise._all(null).then(
      res => console.log(res),
      rej => console.log(rej)
    )
    // throw err: null is not iterable
  } catch (e) {
    console.log(e)
  }

  try {
    Promise._all({}).then(
      res => console.log(res),
      rej => console.log(rej)
    )
    // throw err: [object object] is not iterable
  } catch (e) {
    console.log(e)
  }

  Promise._all([]).then(
    res => console.log(res),
    rej => console.log(rej)
  )
  // []

  Promise._all(new Set()).then(
    res => console.log(res),
    rej => console.log(rej)
  )
  // []

  Promise._all(new Map()).then(
    res => console.log(res),
    rej => console.log(rej)
  )
  // []

  Promise._all([
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.resolve(3),
    4,
  ]).then(
    res => console.log(res),
    rej => console.log(rej)
  )

  // [1, 2, 3, 4]

  Promise._all([
    Promise.reject(1),
    Promise.resolve(2),
    Promise.resolve(3),
    4,
  ]).then(
    res => console.log(res),
    rej => console.log(rej)
  )
  // 1
}
test()
```

### Promise.allSettled

1. Promise.allSettled() 方法接受一组 Promise  实例作为参数，返回一个新的 Promise 实例。
2. 只有等到所有这些参数实例都返回结果，不管是 fulfilled  还是 rejected ，包装实例才会结束。
3. 返回的新 Promise  实例，一旦结束，状态总是 fulfilled ，不会变成 rejected 。
4. 新的 Promise  实例给监听函数传递一个数组 results 。该数组的每个成员都是一个对象，对应传入 Promise.allSettled 的 Promise 实例。每个对象都有 status 属性，对应着 fulfilled  和 rejected 。 fulfilled  时，对象有 value  属性, rejected  时有 reason  属性，对应两种状态的返回值。
5. 有时候我们不关心异步操作的结果，只关心这些操作有没有结束时，这个方法会比较有用。

```js
Promise.allSeleted = function (promises) {
  let count = 0;
  let result = [];
  return new Promise((resolve, reject) => {
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(
          (res) => {
            result[index] = {
              value: res,
              reason: null,
            };
          },
          (err) => {
            result[index] = {
              value: null,
              reason: err,
            };
          }
        )
        .finally(() => {
          count++;
          if (count === promises.length) {
            resolve(result);
          }
        });
    });
  });
};

```

### 手写防抖函数

```js
// 防抖：防止抖动，避免把一次事件误认为多次
// 场景：1）登陆/发消息等按钮点击操作；2）调整浏览器窗口大小；3）文本编辑器实时保存
// 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
function debounce(f, wait) {
  let timer;
  // 返回一个内部函数
  return function(...args) {
    const context = this;
    // 每次被触发，都会清除当前timer并重新设置
    clearTimeout(timer);
    timer = setTimeout(() => {
      f.apply(context, args);
    }, wait);
  };
}
```

### 手写节流函数

```js
// 节流：控制流量
// 场景：1）scroll事件；2）浏览器播放事件；3）input搜索框实时展示下拉列表
// 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
function throttle(f, wait) {
  let lastExecTime = 0;
  return function(...args) {
    const currentTime = Date.now();
    if (currentTime - lastExecTime >= wait) {
      f.apply(this, args);
      lastExecTime = currentTime;
    }
  };
}
```

### 实现 AJAX 请求

```js
function ajax(method, url, data, successCallback, errorCallback) {
  // 创建 XMLHttpRequest 对象
  const xhr = new XMLHttpRequest();

  // 监听 readyState 变化事件
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        // 请求成功，执行成功回调函数
        successCallback(xhr.response);
      } else {
        // 请求失败，执行错误回调函数
        errorCallback(xhr.statusText);
      }
    }
  };
  // 设置请求失败时的监听函数
  xhr.onerror = function () {
    errorCallback(xhr.statusText);
  };

  // 初始化请求
  xhr.open(method, url, true);

  // 设置请求头
  xhr.setRequestHeader("Content-Type", "application/json");
  xhr.responseType = "json";

  // 发送请求
  xhr.send(data);
}

```

### 函数柯里化

把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。

```js
function toCurry(fn, ...args) {
    // ↑需要柯里化的函数作为参数
    // ↑也可以有初始参数传入
    // ↑缓存在args中​
    return (...rest) => {
        // 合并上一次缓存的参数和本次传入的参数
        args = [...args,...rest];
        // 判断参数数量是否足够
        if (args.length < fn.length) {
            // 如果不够，继续递归
            // 注意，这里每一次递归都会形成新的闭包
            // 保证柯里化函数每一步调用都是独立的，互不影响
            return toCurry(fn, ...args);
        } else 
           // 如果参数满足数量，执行函数并返回结果
            return fn.apply(this, args);
        }
    }
}
```

```js
function test(a, b, c, d) {
  return a + b + c + d;
}
console.log(toCurry(test, 1)(2)(3, 4)); // -> 10
```

### 实现深拷贝

```js
function deepClone(target, hash = new WeakMap()) {
  // 获取类型工具函数
  const getType = value => Object.prototype.toString.call(value).slice(8, -1)
  // 1）如果是基本数据类型或函数直接返回
  if (typeof target !== 'object' || target === null) return target
  // 2）对于 Date 和 RegExp，使用构造器新创建一个返回
  if (getType(target) === 'Date') return new Date(target)
  if (getType(target) === 'RegExp') return new RegExp(target)
  // 3) 已经拷贝过的对象直接返回，避免循环引用
  if (hash.get(target)) return hash.get(target)
  // 4）对于 Set 和 Map，使用构造器新创建一个返回，同时需要处理循环引用
  if (getType(target) === 'Set') {
    const set = new Set()
    hash.set(target, set)
    target.forEach(value => {
      set.add(deepClone(value, hash))
    })
    return set
  }
  if (getType(target) === 'Map') {
    const map = new Map()
    hash.set(target, map)
    for (const [key, value] of target) {
      map.set(key, deepClone(value, hash))
    }
    return map
  }
  // 5）对于其他对象，执行对应的构造器获得一个新实例
  const cloneObj = new target.constructor()
  hash.set(target, cloneObj)
  // 使用 Reflect.ownKeys 遍历对象自身的可枚举、不可枚举和 Symbol 值作为键的属性
  Reflect.ownKeys(target).forEach(key => {
    cloneObj[key] = deepClone(target[key], hash)
  })
  return cloneObj
}
```

```js
const obj = {
  name: 'xiaohei',
  bool: true,
  nul: null,
  undef: undefined,
  show: function () {
    console.log('show function')
  },
  num: 20,
  set: new Set([1, 2, 3]),
  map: new Map(),
  date: new Date(),
  reg: /.xml/g,
  info: {
    msg: 'old msg',
  },
  sym: Symbol('a'),
}
obj.obj = obj
obj.map.set('mapKey', 'map-value')
obj.map.set('obj', obj)
const sym = Symbol('sym')
obj[sym] = 1

console.log(deepClone(obj))
```

### 寄生组合式继承

```js
function inheritPrototype(subType, superType) {
  // 创建一个新对象，该对象的原型指向 superType 的原型
  const prototype = Object.create(superType.prototype);
  // 将构造函数指向子类，修复构造函数的指向
  prototype.constructor = subType;
  // 将子类的原型指向新创建的对象，实现继承
  subType.prototype = prototype;
}

function Animal(name) {
  this.name = name;
  this.colors = ['white', 'black'];
}

Animal.prototype.eat = function() {
  console.log(this.name + ' is eating.');
};

function Dog(name) {
  // 调用父类构造函数，并传递必要的参数
  Animal.call(this, name);
  this.type = 'dog';
}

// 使用 inheritPrototype 函数实现继承
inheritPrototype(Dog, Animal);

Dog.prototype.bark = function() {
  console.log(this.name + ' is barking.');
};

const dog = new Dog('Snoopy');
dog.eat(); // 输出 "Snoopy is eating."
dog.bark(); // 输出 "Snoopy is barking."
```

## 数据处理

### 数组去重

```js
// set
function uniqueBySet(arr) {
  return [...new Set(arr)];
}

// reduce
function uniqueByReduce(arr) {
  return arr.reduce((acc, cur) => {
    if (!acc.includes(cur)) {
      acc.push(cur);
    }
    return acc;
  }, []);
}
```

### 数组扁平化

```js
Array.prototype.myFlat = function (depth = 1) {
  return this.reduce((acc, cur) => {
    if (depth === 0) return this;
    return acc.concat(Array.isArray(cur) ? cur.myFlat(depth - 1) : cur);
  }, []);
};
```

```js
console.log([1, 2, 3, [4, [5, 6]]].myFlat()) // -> [ 1, 2, 3, 4, [ 5, 6 ] ]
```

###  判断是否相等

```js
function isEqual(x, y) {
  if (x === y) {
    return true;
  } else if (
    typeof x === "object" &&
    x !== null &&
    typeof y === "object" &&
    y !== null
  ) {
    const keysX = Object.keys(x);
    const keysY = Object.keys(y);
    if (keysX.length !== keysY.length) {
      return false;
    }
    for (const key of keysX) {
      if (!isEqual(x[key], y[key])) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
```

```js
const obj1 = { a: 1, b: { c: 1 } }
const obj2 = { a: 1, b: { c: 2 } }
console.log(isEqual(obj1, obj2)) // -> true
```

### 实现数组的乱序输出

```js
// 使用 sort + 随机数
function shuffle(list) {
  return list.sort((a, b) => Math.random() - 0.5);
}

// 倒序遍历数组，每次生成一个0-i的随机数，与之交换位置
function shuffle(list) {
  const len = list.length;
  let result = [...list];
  for (let i = len - 1; i > 0; i--) {
    const swapIndex = Math.floor(Math.random() * (i + 1));
    [result[i], result[swapIndex]] = [result[swapIndex], result[i]];
  }
  return result;
}
```

### 数字千分位格式化

```js
// 分离负号、整数和小数部分，对整数部分进行格式化
function numberThousands(number) {
  let prefix = "";
  if (number < 0) {
    prefix = "-";
    number = Math.abs(number);
  }
  const numberStr = String(number);
  let result = "";
  let [integer, decimal] = numberStr.split(".");

  while (integer.length > 3) {
    // 倒数三位数字
    let subStr = integer.slice(-3);
    integer = integer.slice(0, -3);
    result = `,${subStr}${result}`;
  }
  // 加上剩下的整数部分
  if (integer.length) {
    result = `${integer}${result}`;
  }
  
  return prefix + result + (decimal ? `.${decimal}` : "");
}
```

```js
// -> '123'
console.log(numberThousands(123));
// -> '1,234,567'
console.log(numberThousands(1234567));
// 可以处理正负数
// -> '-123,456'
console.log(numberThousands(-123456));
// 可以处理小数
// -> '-123,456.123456789'
console.log(numberThousands(-123456.123456789));
```

### 非负大数相加

```js
// 先补位，对齐后每位相加，保存进位标志
function bigSum(a, b) {
  //接收到的是数字，先将他们转换成字符串
  a = '' + a
  b = '' + b
  //获得a和b 较长的一个，为较短的一个前面补0，直到a和b长度相等
  const len = Math.max(a.length, b.length)
  a = a.padStart(len, '0') // 000123
  b = b.padStart(len, '0') // 123456
  //下面会用到的变量
  let t = 0, //每次相加的结果
    f = 0, //是否进位
    sum = '' //最后的和
  //从后向前遍历
  for (let i = len - 1; i >= 0; i--) {
    //此次运算的结果 + 上次是否有进位
    t = parseInt(a[i]) + parseInt(b[i]) + f
    //如果此次结果大于10, 说明下次可以进一位
    //f只可能是1 或 0
    f = Math.floor(t / 10)
    //这一次加的永远是这次的个位， 如果此次结果>10， 会在下次进一位
    sum = (t % 10) + sum
  }
  //如果遍历结束，发现f == 1 表示仍然可以进位， 就在sum最前面+1
  if (f) {
    sum = f + sum
  }
  return sum
}
```

```js
let a = Number.MAX_SAFE_INTEGER, //9007199254740991 
	b = 12
console.log(bigSum(a, b)) // -> 9007199254741003
```

### 无限累加的 sum 函数

```js
function sum(...args) {
  const f = (...rest) => sum(...args, ...rest);
  f.valueOf = () => args.reduce((x, y) => x + y, 0);
  return f;
}
```

```js
console.log(sum(1, 2, 3).valueOf()); //6
console.log(sum(2, 3)(2).valueOf()); //7
console.log(sum(1)(2)(3)(4).valueOf()); //10
console.log(sum(2)(4, 1)(2).valueOf()); //9
console.log(sum(1)(2)(3)(4)(5)(6).valueOf()); // 21
```

### 解析/格式化 URL Params

```js
function stringify(data) {
  const pairs = Object.entries(data);
  return pairs
    .map(([k, v]) => {
      let noValue = false;
      if (v === null || v === undefined || typeof v === "object") {
        noValue = true;
      }
      return `${encodeURIComponent(k)}=${noValue ? "" : encodeURIComponent(v)}`;
    })
    .join("&");
}

function parse(url) {
  const dict = {};
  url.replace(/([^?&]*)=([^&#]*)/g, (_, key, val) => {
    key = decodeURIComponent(key);
    val = decodeURIComponent(val);
    if (dict[key]) {
      dict[key] = [].concat(dict[key], val);
    } else {
      dict[key] = val;
    }
  });
  return dict;
}


// 使用 URLSearchParams
function parse(url) {
  let params = new URLSearchParams(url),
    queryObj = {};
  for (let [k, v] of params.entries()) {
    if (queryObj[k]) {
      queryObj[k] = [].concat(queryObj[k], v);
    } else {
      queryObj[k] = v;
    }
  }
  return queryObj;
}
```

```js
console.log(stringify({ a: 3, 山: '月' }))

// {}
console.log(parse('https://shanyue.tech'))
// {a: ''}
console.log(parse('https://shanyue.tech?a'))
// {name: '山月'}
console.log(parse('https://shanyue.tech?name=%E5%B1%B1%E6%9C%88'))   
// {name: '山月', a: 3}                
console.log(parse('https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3'))            
// {name: '山月', a: [3, 4]}
console.log(parse('https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3&a=4'))
// {name: '山月', a: 3}
console.log(parse('https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3#hash'))
// {name: '1+1=2'}
console.log(parse('https://shanyue.tech?name=1%2B1%3D2'))
```

### 实现一个异步的 sum

实现一个 sum 函数，接收一个数组 arr 进行累加，并且只能使用 add 异步方法
add 函数已实现，模拟异步请求后端返回一个相加后的值

```js
function add(a, b) {
  return Promise.resolve(a + b);
}

// 异步串行 迭代 + promise
function sum(arr) {
  // Promise.resolve传人一个promise会等传人的promise执行完毕再then
  return arr.reduce((pre, next) => {
    // 瞬间循环完，然后会将当前作为一个primise返回到下一个，
    //利用Promise.resolve入参是promise会等待的特点，异步线程会串行相加
    return Promise.resolve(pre).then((x) => add(x, next));
  }, 0);
}

// 异步串行 : async await 实现异步串行
async function sum(arr) {
  let res = 0;
  for (let item of arr) {
    res = await add(res, item);
  }
  return res;
}

// 并行 + 控制并发
function chunk(arr, size = 2) {
  const res = [];
  for (let i = 0; i < arr.length; i += size) {
    res.push(arr.slice(i, i + size));
  }
  return res;
}

function pMap(list, mapper, concurrency = Infinity) {
  return new Promise((resolve, reject) => {
    let currentIndex = 0;
    let result = [];
    let resolveCount = 0;
    let len = list.length;
    function next() {
      const index = currentIndex++;
      Promise.resolve(list[index])
        .then((o) => mapper(o, index))
        .then((o) => {
          result[index] = o;
          if (++resolveCount === len) {
            resolve(result);
          }
          if (currentIndex < len) {
            next();
          }
        });
    }
    for (let i = 0; i < concurrency && i < len; i++) {
      next();
    }
  });
}
function sum(arr, concurrency) {
  if (arr.length === 1) return arr[0];
  return pMap(
    chunk(arr, 2),
    ([x, y]) => {
      return y === undefined ? x : add(x, y);
    },
    concurrency
  ).then((list) => sum(list, concurrency));
}
```

```js
sum([2, 3, 4, 5, 6, 7, 10]).then(o => console.log(o)) // -> 37
```

### 生成一个随机字符串

```js
// 将随机数转为36进制，由0-9，a-z构成
function randomStr(n) {
  return Math.random()
    .toString(36)
    .slice(2, 2 + n);
}
```

### lodash.get

```js
function get(source, path, defaultValue = undefined) {
  // a[3].b -> a.3.b -> [a, 3, b]
  const paths = path
    .replace(/\[(\w+)\]/g, ".$1")
    .replace(/\["(\w+)"\]/g, ".$1")
    .replace(/\['(\w+)'\]/g, ".$1")
    .split(".");
  let result = source;
  for (const p of paths) {
    result = result?.[p];
  }
  return result === undefined ? defaultValue : result;
}
```

```js
const object = { a: [{ b: { c: 3 } }] }; 
//=> 3
get(object, "a[0].b.c"); 
//=> 3
get(object, 'a[0]["b"]["c"]'); 
//=> 10086
get(object, "a[100].b.c", 10086);
```

### 实现组合函数

```js
function compose(...fn) {
  if (!fn.length) return (v) => v;
  if (fn.length === 1) return fn[0];
  return fn.reduce(
    (pre, cur) =>
    (...args) =>
    pre(cur(...args))
  );
}
```

```js
function fn1(x) {
  return x + 1;
}
function fn2(x) {
  return x + 2;
}
function fn3(x) {
  return x + 3;
}
function fn4(x) {
  return x + 4;
}
const a = compose(fn1, fn2, fn3, fn4);
console.log(a(1)); // 1+4+3+2+1=11
```

### 树形结构转列表

```js
function treeToList(data) {
  const res = []
  const dfs = (data, parentId) => {
    data.forEach(item => {
      if (parentId) {
        item.parentId = parentId
      }
      res.push(item)
      if (item.children) {
        dfs(item.children, item.id)
        delete item.children
      }
    })
  }
  dfs(data)
  return res
}
```

```js
const data = [
  {
    id: '1',
    name: '父节点1',
    children: [
      {
        id: '1-1',
        name: '子节点1-1',
        children: [
          {
            id: '1-1-1',
            name: '子节点1-1-1',
          },
          {
            id: '1-1-2',
            name: '子节点1-1-2',
          },
        ],
      },
    ],
  },
  {
    id: '2',
    name: '父节点2',
    children: [
      {
        id: '2-1',
        name: '子节点2-1',
      },
    ],
  },
]
console.log(treeToList(data))
```

### 列表转树形结构

```js
function listToTree(arr) {
  const list = []
  const map = new Map()

  for (let i = 0; i < arr.length; i++) {
    // 存储每个id下的子元素
    let pid = arr[i].pid
    let id = arr[i].id

    // 如果未保存过 id 对象，新建一个保存
    if (!map.has(id)) {
      map.set(id, { children: [] })
    }

    map.set(id, { ...arr[i], children: map.get(id).children })

    if (pid === 0) {
      list.push(map.get(id))
    } else {
      // 如果未保存过 pid 对象，新建一个保存
      if (!map.has(pid)) {
        map.set(pid, { children: [] })
      }

      map.get(pid).children.push(map.get(id))
    }
  }
  return list
}
```

```js
let arr = [
  { id: 2, name: "部门2", pid: 1 },
  { id: 5, name: "部门5", pid: 4 },
  { id: 1, name: "部门1", pid: 0 },
  { id: 3, name: "部门3", pid: 1 },
  { id: 4, name: "部门4", pid: 3 },
  { id: 6, name: "部门6", pid: 0 },
];
console.log(listToTree(arr));
```

## 场景应用

### 发布订阅模式

```js
class Event {
  events = {};

  emit(type, ...args) {
    const listeners = this.events[type];
    for (const listener of listeners) {
      listener(...args);
    }
  }

  on(type, listener) {
    this.events[type] = this.events[type] || [];
    this.events[type].push(listener);
  }

  once(type, listener) {
    const callback = (...args) => {
      this.off(type, callback);
      listener(...args);
    };
    this.on(type, callback);
  }

  off(type, listener) {
    this.events[type] = this.events[type] || [];
    this.events[type] = this.events[type].filter(
      (callback) => callback !== listener
    );
  }
}
```

```js
const e = new Event();
const callback = (x) => {
  console.log("Click", x.id);
};
e.on("click", callback);
e.on("click", callback);
// 只打印一次
const onceCallback = (x) => console.log("Once Click", x.id);
e.once("click", onceCallback);
e.once("click", onceCallback);
//=> 3
e.emit("click", { id: 3 });
//=> 4
e.emit("click", { id: 4 });
```

### 循环打印红黄绿

红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？

```js
function sleep(seconds = 0) {
  return new Promise((resolve) => setTimeout(resolve, seconds));
}

async function start() {
  const lights = [
    ["red", 3000],
    ["yellow", 2000],
    ["green", 1000],
  ];

  const len = lights.length;
  let i = 0;
  while (true) {
    await sleep(lights[i % len][1]);
    console.log(lights[i % len][0]);
    i++;
  }
}
start();
```

### 将虚拟 DOM 转化成真实 DOM

```js
// 真正的渲染函数
function _render(vnode) {
  // 如果是数字类型转化为字符串
  if (typeof vnode === "number") {
    vnode = String(vnode);
  }
  // 字符串类型直接就是文本节点
  if (typeof vnode === "string") {
    return document.createTextNode(vnode);
  }
  // 普通DOM
  const dom = document.createElement(vnode.tag);
  if (vnode.attrs) {
    // 遍历属性
    Object.keys(vnode.attrs).forEach((key) => {
      const value = vnode.attrs[key];
      dom.setAttribute(key, value);
    });
  }
  // 子数组进行递归操作
  vnode.children.forEach((child) => dom.appendChild(_render(child)));
  return dom;
}
```

```js
const vnode = {
  tag: "DIV",
  attrs: {
    id: "app",
  },
  children: [
    {
      tag: "SPAN",
      children: [{ tag: "A", children: [] }],
    },
    {
      tag: "SPAN",
      children: [
        { tag: "A", children: [] },
        { tag: "A", children: [] },
      ],
    },
  ],
};
console.log(_render(vnode));
```

### 实现双向绑定（v-model）

```js
let obj = {};
let input = document.getElementById("input");
let span = document.getElementById("span");
// 数据劫持
Object.defineProperty(obj, "text", {
  configurable: true,
  enumerable: true,
  get() {
    console.log("获取数据了");
  },
  set(newVal) {
    console.log("数据更新了");
    input.value = newVal;
    span.innerHTML = newVal;
  },
});
// 输入监听
input.addEventListener("keyup", function (e) {
  obj.text = e.target.value;
});

```

## 算法

### LRU 缓存

实现 `LRUCache` 类：
- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

[[146.LRU 缓存]]

### 快速排序

[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/description/)

```js
// 对 arr 中 left 到 right 闭区间的元素进行排序
function quickSort(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        const partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
    }
    return arr;
}

// 对 arr 中 left 到 right 闭区间的元素进行排序并返回基准索引
function partition(arr, left, right) {
    let pivotIndex = left, // 设定分区中第一个元素为基准值
        index = left + 1; // index 前的元素都比基准小

    // 将分区中剩下的元素与基准进行比较，比基准小的元素移到前面
    for (let i = left + 1; i <= right; i++) {
        if (arr[i] < arr[pivotIndex]) {
            // 每找到一个比基准小的元素，就交换到前面
            [arr[i], arr[index]] = [arr[index], arr[i]];
            index++;
        }
    }

    // 把基准交换到正确位置 index - 1
    [arr[index - 1], arr[pivotIndex]] = [arr[pivotIndex], arr[index - 1]];

    return index - 1;
}
```

### 二分查找

[二分查找](https://leetcode.cn/problems/binary-search/description/ "https://leetcode.cn/problems/binary-search/description/")

```js
var search = function (nums, target) {
  // 搜索区间 - [left, right] 左闭右闭
  let left = 0,
    right = nums.length - 1;

  // 当left > right时搜索区间[left, right]不存在，终止循环
  while (left <= right) {
    let mid = Math.floor(left + (right - left) / 2);

    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] < target) {
      // mid 已经搜索过了，取 [mid + 1, right] 为下一个区间
      left = mid + 1;
    } else if (nums[mid] > target) {
      // mid 已经搜索过了，取 [left, mid - 1] 为下一个区间
      right = mid - 1;
    }
  }
  return -1;
};
```

### topK

```js
class Heap {
    constructor(arr) {
        this.arr = arr;
        this.size = arr.length; // 维护数组无序区长度
    }

    // 建立大顶堆
    buildMaxHeap() {
        for (let i = Math.floor(this.size / 2); i >= 0; i--) {
            this.heapify(i);
        }
    }

    // 对 arr[i] 进行堆调整
    heapify(i) {
        let max = i;
        const left = i * 2 + 1;
        const right = left + 1;

        // 将 arr[i] 与两个子节点进行比较，选出最大的
        if (left < this.size && this.arr[left] > this.arr[max]) {
            max = left;
        }
        if (right < this.size && this.arr[right] > this.arr[max]) {
            max = right;
        }

        // 本身最大则无需调整
        if (max === i) return;

        // 将最大的子节点与父节点交换
        [this.arr[i], this.arr[max]] = [this.arr[max], this.arr[i]];

        // 递归调整 arr[max]
        this.heapify(max);
    }

    // 堆排序
    sort() {
        this.buildMaxHeap();

        // 当无序区数组长度为 1 时排序完成
        while (this.size > 1) {
            // 将最后一个无序区节点与第一个节点交换
            [this.arr[0], this.arr[this.size - 1]] = [
                this.arr[this.size - 1],
                this.arr[0],
            ];
            // 无序区数组长度减 1
            this.size--;
            // 进行堆调整
            this.heapify(0);
        }
        return this.arr;
    }
}
```
