### 有哪些可能引起前端安全的问题?

- **XSS（跨站脚本）** 攻击者通过在网站注入恶意脚本，使之==在用户的浏览器上运行==。
- **CSRF（跨站点请求伪造）** 攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态冒充用户执行一些操作。CSRF 攻击的本质是==利用 cookie 会在同源请求中携带发送给服务器的特点==，以此来实现用户的冒充。
- **iframe 的滥用** iframe 中的内容是由第三方来提供的，他们可以在 iframe 中运行 JavaScirpt 脚本、Flash 插件、弹出对话框等等，这可能会破坏前端用户体验。
- **恶意第三方库** 如果引入的第三方库被植入恶意代码很容易引起安全问题。

#### XSS 有哪些类型？

- **存储型** 攻击者将恶意代码提交到网站的数据库中，当浏览器请求数据时，脚本被拼接在 HTML 中从服务器传回执行。（==网站对用户输入审查不严==）
- **反射型** 攻击者诱导用户访问一个带有恶意代码的 URL 后，网站服务端没有对 url 的恶意代码进行净化就将其拼接在 html 返回给浏览器执行。（==服务端未对 url 参数进行净化或过滤==）
- **DOM 型** 攻击者诱导用户访问一个带有恶意代码的 URL 后，前端脚本未对 url 参数进行净化或过滤就执行或插入 dom 中（==eval，innerHTML 等，前端漏洞==）
- **区别** 存储型和反射型都是服务端的漏洞，DOM 型是前端的漏洞；存储型的恶意脚本存储在数据库里，反射型和 DOM 型的恶意脚本存储在 URL 中

#### 如何防御 XSS 攻击？

-  **CSP（内容安全策略）** 本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 `Content-Security-Policy`，一种是设置 meta 标签的方式 `<meta http-equiv="Content-Security-Policy">`
- cookie 设置 `http-only`，使得脚本无法获取 cookie
- 在==处理用户输入、数据获取和字符串拼接==时应该对可能出现恶意代码的情况进行判断

#### CSRF 有哪些类型？

- **GET 类型** 在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
- **POST 类型** 构建一个隐藏的表单，当用户进入页面时，自动提交这个表单。
- **链接类型** 在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

#### 如何防御 CSRF 攻击?

-  **对 Cookie 进行双重验证** 服务端再添加一个 Cookie，保存一个随机数。前端提交请求的时候 hash 这个随机数，服务端收到请求后用同样的算法 hash 设置在客户端的随机数，两者一致则合法。（恶意网站无法读取第一方的 Cookie，也就无法 hash 这个随机数）
- **cookie 设置 SameSite**（ `Set-Cookie: CookieName=CookieValue; SameSite=Strict｜Lax｜None`）。SameSite 有两种模式：严格模式下 cookie 在任何情况下都不能作为第三方 Cookie 使用；宽松模式下，cookie 可以被 GET 请求携带，或者是链接 `<a href="..."></a>` 预加载 `<link rel="prerender" href="..."/>`
- **同源检测** 服务端根据请求头中 origin 或者 referer 信息来判断请求是否被允许。

### 什么是同源策略？

- **同源** 域名，协议，端口相同（二级域名也要相同）
- 非同源受到的限制:
	- Cookie、LocalStorage 和 IndexDB 无法读取
	- dom 无法获得
	- AJAX 请求不能响应（允许跨域加载资源的标签 img、link、script）

### 跨域有哪些方式？

**JSONP**

利用了 `<script>` 标签没有跨域限制，仅支持 get 请求，需要服务端支持

- 动态创建一个 `<script>` 标签，把跨域的接口地址赋值给 script 的 src，并且通过 url 参数拼接上回调函数名
- 服务器收到请求后，把函数名和返回的数据拼接成函数调用的形式 `fn(data)`
- 浏览器运行浏览器返回的结果，即调用了回调函数并将请求结果作为参数传入

**CORS（跨域资源共享）**

服务端在响应头配置 `Access-Control-Allow-Origin`，表示哪些域名可以访问资源，浏览器看到这个字段的值与当前的源匹配，就会解锁跨域限制。

请求有两种情况

- ==简单请求：直接发送到服务器（可能会造成 CSRF）==
	- 请求方法使用 GET、POST 或 HEAD
	- Content-Type 设为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain
- 复杂请求：浏览器会在真正请求前发送==OPTION 方法的预检请求== 向服务器询问当前源是否符合 CORS 目标，验证通过后才会发送正式请求。（用于跨域的 CORS 请求默认不发送 Cookie 和 HTTP 认证信息，前后端都要在配置中设定请求时带上 cookie）
	- put
	- application/json

**Node 中间件代理（两次跨域）**

同源策略是浏览器需要遵循的标准，而如果是==服务器向服务器请求就无需遵循同源策略==。

![[Pasted image 20240109193620.png]]

**Nginx 反向代理**

通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。

**WebSocket**

WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据，可以进行跨域通信。

**postMessage**

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的 iframe 消息传递
- 上面三个场景的跨域数据传递

#### 关于跨域需要明确的问题

跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。

每次需求都会发出，服务器端也会做出响应，只是浏览器端在接受响应的时候会基于同源策略进行拦截。

注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。

### 对浏览器的缓存机制的理解？

浏览器缓存的全过程:

1. 浏览器第一次请求成功后，下载并缓存资源文件与响应头，以供下次加载时对比使用;
2. 再次请求已缓存的资源时，如果未禁用强缓存（no-cache），就通过 max-age 或 expires 来判断是否命中强缓存；
3. 如果过期，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求;
4. 服务器收到请求后，根据 Etag 的值判断被请求的文件有没有修改，Etag 值一致则没有修改，命中协商缓存，返回 304; 如果不一致则有改动，返回新的资源文件带上新的 Etag 值，返回 200;
5. 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304; 不一致则返回新的 last-modified 和文件并返回 200;

*很多网站的资源后面都加了版本号，这样做的目的是: 每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时 获得网站的最新更新。*

#### 三种页面刷新方式的区别？

- **点击刷新按钮或者按 F5** 浏览器对本地的缓存文件过期，进行协商缓存（带上 If-Modifed-Since，If-None-Match 向服务器请求）
- **Ctrl+F5(强制刷新)** 不走强缓存和协商缓存，相当于没请求过
- **地址栏回车** 浏览器按正常流程，检查强缓存，协商缓存

### 前端的存储方式有哪些？

- **cookie**
	- 记录用户状态，在同源请求中自动携带
	- 最多存储 4k
	- 生存时间由 expires 或 max-age 指定
	- 在同站的页面中共享（有效顶级域名 + 二级域名一致，不需要考虑协议和端口）
- **localStorage**
	- html5 提供的浏览器本地存储方法
	- 一般为 5M
	- 除非手动删除，否则不会失效
	- 在同源的页面中共享
- **sessionStorage**
	- html5 提供的浏览器本地存储方法
	- 一般为 5M
	- 在当前窗口关闭后失效
	- 在同一窗口的同源页面中共享
- **IndexedDB**
	- 纳入 HTML5 标准的数据库储存方案，使用键值对存储在 objectStore 中，所有的操作都是异步的
	- 用于存储大量数据（Chrome 的限制：硬盘可用空间的三分之一）
	- 除非手动删除，否则不会失效
	- 在同源的页面中共享

#### 如何使用离线存储？

**service worker**

Service Worker 是浏览器和网络之间的虚拟代理，运行在一个与页面 JavaScript 主线程独立的线程上，无法访问 DOM，但是可以使用 `self` 访问全局上下文。可以做离线处理和消息推送等。

使用的流程：
1. 在 `install` 后缓存指定的文件列表
2. 在 `activate` 后更新缓存
3. 用 `fetch` 来拦截请求直接返回缓存数据。

**~~manifest（已移出标准）~~**

基于 manifest(缓存清单文件，后缀名为.appcache) 的缓存机制（不是存储技术），通过这个文件上的清单解析存储离线资源。用户没有联网时，可以正常访问站点或 web 应用；联网后，更新用户机器上的缓存文件。

使用方法：

1. 在文档的 html 标签中设置 manifest 属性，引用 manifest 文件。`<html lang="en" manifest="index.cache">`
2. 配置 manifest 文件，在文件中编写离线存储的资源。

```
CACHE MANIFEST

# 要缓存的文件
CACHE:
    images/img1.jpg
    images/img2.jpg

# 指定必须联网才能访问的文件
NETWORK:
    images/img3.jpg
    images/img4.jpg

# 当前页面无法访问是回退的页面或者访问不到某资源时替换的资源
FALLBACK:
    404.html
```

### 什么是浏览器内核？

主要分成两部分
- **渲染引擎** 渲染页面
- **JS 引擎** 解析和执行 javascript

#### 常见的浏览器内核？

- **Webkit** Safari 的内核，网页浏览速度快，但是对于代码容错性不高
- **Blink** Chrome 和 Opera 的内核，是**Webkit** 的一个分支
- **Gecko**：Firefox 的内核，功能强大丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是要消耗很多资源

### 浏览器的渲染过程？

![[Pasted image 20240110162007.png]]

- 解析 HTML 文档，**构建一棵 DOM 树**。（DOM 树是由 DOM 元素及属性节点组成）
- 解析 CSS，**生成 CSSOM （CSS Object Model） 规则树**
- 根据 DOM 树和 CSSOM 规则树**构建渲染树**。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们 一般是一些具有复杂结构的元素，无法用一个矩形来描述。
- 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局 (也可以叫做回流)。 这一阶段浏览器要做的事情是要**弄清楚各个节点在页面中的确切位置和大小**。通常这一行为也被称为“自动重排”。
- **绘制阶段**，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

#### 什么是重绘和回流（重排）？

- **重绘**: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 `background-color`，我们将这样的操作称为重绘。
- **回流（重排）**：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。
- **关系** 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

#### 如何减少回流？

- 使用 vue/react 等前端框架，我们只操作数据，让框架自动根据数据变化渲染视图（虚拟 DOM）
- 利用**渲染队列**机制，把修改样式的代码写在一起。（渲染队列：遇到一行修改样式的代码，先放到渲染队列中，继续看 **下面一行代码** 是否还为修改样式的，如果是继续增加到渲染队列中...直到下面的代码不再是修改样式的，而是获取样式的代码！此时不再向渲染队列中增加，把之前渲染队列中要修改的样式一次性渲染到页面中，引发一次 DOM 的回流和重绘）
- **批量修改元素**。创建一个**文档碎片**（documentFragment ），在里面创建好 DOM 后再一起添加到页面上
- 将元素先设置 `display: none`，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
- 使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
- 通过修改样式类或 cssText **集中改变样式**

#### 渲染过程中遇到 JS 文件怎么处理？

JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在 构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。

#### async 和 defer 的作用是什么？有什么区别？

- 未设置时，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
- defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，DOMContentLoaded 事件触发之前完成。**多个脚本按顺序执行**。
- async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。**多个脚本的执行顺序无法保证**。

#### CSS 如何阻塞文档解析？

如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，**浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析**。
