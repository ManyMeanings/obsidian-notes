### js 有哪些数据类型？

原始数据类型有 7 种：`Number`、`String`、`Boolean`、`Undefined`、`Null`、`Symbol`、`BigInt`
引用数据类型：`Object`、`Function`、`Array` ...

#### 它们的存储方式是怎样的？

原始数据类型存储在栈 (stack) 中，占据空间小、大小固定。

引用数据类型存储在堆 (heap) 中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。

#### null 和 undefined 的区别?

null 表示一个 " 无 " 的对象，也就是该处不应该有值；而 undefined 表示未定义。 在转换为数字时结果不同，Number(null) 为 0，而 undefined 为 NaN。

使用场景上：

- null：
    - 作为函数的参数，表示该函数的参数不是对象
    - 作为对象原型链的终点
- undefined:
    - 变量被声明了，但没有赋值时，就等于 undefined
    - 调用函数时，应该提供的参数没有提供，该参数等于 undefined
    - 对象没有赋值属性，该属性的值为 undefined
    - 函数没有返回值时，默认返回 undefined

### 判断数据类型有哪些方式？

- `Object.prototype.toString.call()`
	- 可以完美判断类型：`[object Array]`、`[object Number]` ...
	- 原理：返回当前调用者的对象类型（*所有数据类型都是对象的一种类型*）
	- 为什么不直接用 toString：每个对象类都重写了 toString 方法
- `typeof`
	- `object`、`number`、`bigint`、`function`
	- 基本数据类型返回对应值（*Null 返回 object*），引用数据类型返回 object 或 function（*数组返回 object*）
- `instanceof`
	- 只能正确判断引用数据类型
	- 原理：判断在其原型链中能否找到该类型的原型
- `constructor`
	- `('').constructor === String // true`
	- 访问对象实例的构造函数
	- 无法用于 null 和 undefined；如果手动改变了对象的原型，结果姐不准确了

### `Object.is()` 与比较操作符 `===`、`==` 的区别?

`==` 如果两边的类型不一致，则会进行类型转换后再进行比较。

`===` 如果两边的类型不一致，直接返回 false

`Object.is()` 大部分情况与全等结果相同，不同在于：**正负 0 比较不相等，两个 NaN 比较相等**

#### 有哪些假值？

6 个假值：`undefined`、`null`、`NaN`、`0`、`""`（空字符串）和 `false`

### 什么是 JavaScript 中的包装类型?

在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象。

#### 包装类型和基本类型的相互转换

```js
let a = 'abc'
let b = Object(a) // String(a)
let c = b.valueOf() // 'abc'
```

### 对 this 对象的理解？

哪个对象调用函数，函数里面的 this 指向哪个对象

- **方法调用**，this 总是指向调用它所在方法的对象，this 的指向与所在方法的调用位置有关，而与方法的声明位置无关（箭头函数特殊）；
- **函数调用**，调用方法没有明确对象的时候，this 指向 window，如 setTimeout、匿名函数等；
- **构造函数调用**模式下，this 指向实例对象；
- **事件**绑定函数的形式调用时，this 指向绑定事件的对象；
- **apply,call,bind**，this 指向第一个参数；
- **箭头函数**，在声明的时候绑定 this，而非取决于调用位置；
- 严格模式下，如果 this 没有被执行环境（execution context）定义，那 this 是 undefined；

#### 箭头函数的 this 指向？

箭头函数体内的 `this` 对象，就是**定义该函数时所在的作用域指向的对象**（*对象不是作用域*），而不是使用时所在的作用域指向的对象。

```js
var name = 'window'; 

var A = {
   name: 'A',
   sayHello: () => {
      console.log(this.name)
   }
}

A.sayHello();// 还是以为输出A ? 错啦，其实输出的是window
```

### apply，call，bind 三者的区别？

- 三者都可以改变函数的 this 对象指向。
- 三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window。
- 三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入。
- bind 是返回绑定 this 之后的函数，便于稍后调用；apply 、call 则是立即执行 。

### 箭头函数与普通函数的区别？

- 箭头函数没有独立的 `this`、`arguments` 和 `super`，并且不可被用作方法。
- 箭头函数不能用作构造函数。
- 箭头函数不能在其主体中使用 `yield`，也不能作为生成器函数创建。

### 扩展运算符的使用场景？

对象：
- 取出参数对象中的所有可枚举属性，拷贝到当前对象之中（*浅拷贝*）
- 可用于对象合并、修改对象的部分属性
数组：
- 将一个数组转为用逗号分隔的参数序列
- 可用于复制数组、合并数组、函数传参、将 Iterator 接口的对象转换为数组

### 什么是原型和原型链？

- 每个对象都有一个 `__proto__` 属性，称为隐式原型
- 每个构造函数除了有隐式原型外，还有一个 `prototype` 属性，称为显式原型
- 显式原型定义了所有构造函数创建的实例所共享的属性和方法
- 两者的关系是：**隐式原型指向创建这个对象的构造函数的显式原型**
- **原型链** 当访问一个对象的属性时，如果该对象本身不存在这个属性，那么就会沿着原型链往上查找，直到找到该属性或原型链的末尾（*null*）为止

### 什么是执行上下文？

执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。执行上下文类型分为：

- 全局执行上下文
- 函数执行上下文

执行上下文创建过程中，需要做以下几件事:

1. 创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。
2. 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。
3. 确定 this 的值，即 ResolveThisBinding

### 什么是作用域？

作用域就是一个变量可访问和可见的区域

三种作用域：
- 全局作用域：任何不在函数中或是大括号中声明的变量，可以在程序的任意位置访问
- 函数作用域：在函数中声明的变量，只能在函数内部访问
- 块级作用域：在大括号中使用 `let` 和 `const` 声明的变量，在大括号之外不能访问

#### 什么是作用域链？

作用域之间存在嵌套关系，当使用一个变量的时候，Javascript 引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推。

#### 什么是词法作用域？

词法作用域也叫静态作用域，作用域在词法化阶段（通常是编译阶段）确定而非执行阶段确定。使用词法作用域，我们可以仅仅看源代码就可以确定一个变量的作用范围，但如果是动态作用域，代码执行之前我们没法确定变量的作用范围。

#### 什么是词法环境？

词法环境是 Javascript 引擎用来存储变量和对象引用的地方。只有当作用域的代码被执行的时候，引擎才会为作用域创建一个新的词法环境。词法环境还会记录所引用的外部词法环境 (即外部作用域)。

```js
lexicalEnvironment = { 
a: 25, 
obj: <ref. to the object>
outer: <outer lexical environemt> 
}
```

#### 什么是变量提升？

- `var` 变量会进行声明提前，在赋值前可以访问到这个变量，值是 `undefined`
- 函数声明也会被提前，而且优先级比 `var` 高
- 块级作用域也有“变量提升”，但是会形成“暂时性死区”，在声明前访问会直接报错

```js
var x = 1;
if(true) {
  // 暂时性死区
  console.log(x);
  
  let x = 2;
}
```

#### let 和 const 的特点？

1. 可以产生块级作用域：使用 let 和 const 声明的变量拥有块级作用域，可以避免变量污染和命名冲突等问题。
2. 不会发生变量提升：使用 let 和 const 声明的变量不会像 var 声明的变量一样发生变量提升。
3. 使用 const 声明的变量是常量，不可修改，可以确保代码的可靠性和安全性。
4. const 声明变量时必须设置初始值
5. 相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。

### 什么是闭包？

**什么是闭包**：闭包使函数可以访问其父函数的所有变量，即使在父函数返回之后也是如此。

**为什么要有闭包**：如果没有闭包，函数在调用栈上执行，在栈内存中存储局部变量，执行完后出栈，栈上保存的局部变量就无法访问了。

**闭包的实现**：js 引擎会将函数闭包所需的数据，构成一个 `Closure` 对象存储在堆里，然后函数引用这个对象，再次调用时，函数会去访问 `Closure` 对象里的数据。

#### 闭包的使用场景？

闭包可以保存局部变量，且不影响全局变量（*创建私有变量*）。使用闭包时要注意内存泄漏问题，用完就解绑定相关变量。

- 高阶函数：节流防抖、科里化
- 模拟私有变量
- 自执行函数

### 什么是事件循环？

1. JavaScript 中的任务分为**同步任务和异步任务**，异步任务又包括**宏任务和微任务**
2. 同步任务按顺序在执行栈中执行，遇到异步任务就添加到宏任务队列或微任务队列等待执行
3. 同步任务执行完成后，从宏任务队列取出第一个任务执行
4. 执行完成后，按顺序执行所有的微任务（*执行微任务过程中产生的新的微任务在当前的循环中继续执行*）
5. 一次事件循环会处理一个宏任务和所有产生的微任务（*第一次循环中初始化代码就是一次宏任务，因此会先执行完所有的微任务再执行代码中的下一个宏任务*）

#### 什么是宏任务和微任务？

- 宏任务：需要特定的异步线程去执行，有明确的异步任务去执行，有回调；
	- 网络请求、浏览器事件、setTimeout、setInterval、setImmediate
- 微任务：不需要特定的异步线程去执行，没有明确的异步任务去执行，只有回调；
	- Promise、MutaionObserver、process.nextTick(Node.js 环境)；

### 讲一下你对 JS 异步的理解？

**callback**

回调函数是最早被广泛使用的一种方式。通过将耗时的操作封装在一个函数中，并将该函数作为参数传递给异步操作，异步操作完成后会调用该函数，从而达到异步编程的效果。但是嵌套层数太多的回调函数会造成回调地狱，不利于代码阅读和异常处理。

**Promise**

Promise 是 ES6 中新增的一种异步编程方式，它可以更好地管理异步操作的状态，并且可以避免回调函数嵌套的问题。Promise 有三种状态：pending（进行中）、fulfilled（已完成）和 rejected（已拒绝），在异步操作完成后，Promise 对象的状态会从 pending 变为 fulfilled 或 rejected，同时可以通过 then() 和 catch() 方法来处理异步操作的结果。

**async/await**

async/await 是 ES8 中新增的异步编程方式，它使用起来更加简洁和直观，可以将异步操作看作同步操作来处理，提高了代码的可读性和可维护性。async/await 基于 Promise 实现，使用 async 关键字声明异步函数，并使用 await 关键字等待异步操作的结果。

#### 对 Promise 的理解？

Promise 是一个构造函数，接收一个执行器函数作为参数，返回一个 Promise 实例。 一个 Promise 实例有三种状态，分别是 pending、fulfilled 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变， 就凝固了，无法再被改变了。执行器函数接收两个函数 resolve 和 reject 作为参数，可以在异步操作结束后调用这两个函数来改变状态。Promise 实例有一个 then 方法，它接收两个函数作为参数，在状态改变后调用。

#### Ajax 是什么?

Ajax 是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 请求，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面。

### 对 JS 垃圾回收机制的理解？

- **可达值** 以某种方式可访问或可用的值
	- 根：可达值的基本集合，如当前执行函数的局部变量和参数、当前嵌套调用链上的其他函数的局部变量和参数、全局变量等
	- 如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的
- JS 引擎定期执行垃圾回收：从根出发，找到所有可达的值打上标记，没有被标记的对象都会被删掉
- 优化：
	- **分代收集**：对象被分成两组：“新的”和“旧的”，优先跟踪新对象，降低旧对象的检查频次
	- **增量收集**：将整个对象集拆分成多个部分，逐一清除
	- **闲时收集**：在 CPU 空闲时尝试运行垃圾回收

#### 如何识别内存泄漏？

![[Pasted image 20240119160858.png]]

1. 打开开发者工具，选择 Timeline 面板
2. 在顶部的 `Capture` 字段里面勾选 Memory
3. 点击左上角的录制按钮。
4. 在页面上进行各种操作，模拟用户的使用情况。
5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。
6. 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏；反之，就是内存泄漏了。

#### 常见的内存泄漏？

- **意外的全局变量** 当全局变量使用不当，没有及时回收（手动赋值 null），或者拼写错误等将某个变量挂载到全局变量时
- **遗忘的定时器** setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，所以当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器的话，那么这些定时器还是存活着的。如果此时再次打开同个页面，内存中其实是有双份页面数据的，如果多次关闭、打开，那么内存泄漏会越来越严重
- **使用不当的闭包** 正常来说，闭包并不是内存泄漏，因为这种持有外部函数词法环境本就是闭包的特性，就是为了让这块内存不被回收，因为可能在未来还需要用到，但这无疑会造成内存的消耗，所以，不宜烂用就是了
- **遗漏的 DOM 元素** DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了。但如果某个 DOM 元素，在 js 中也持有它的引用时，那么它的生命周期就由 js 和是否在 DOM 树上两者决定了，记得移除时，两个地方都需要去清理才能正常回收它
- **遗忘的事件监听器** 活动事件侦听器将防止在其范围内捕获的所有变量被垃圾收集。添加后，事件侦听器将一直有效，直到使用 removeEventListener() 显式删除或者关联的 DOM 元素被移除。
- **缓存** 如果不断地将对象添加到缓存（*Map*）中，而不删除未使用的对象，那么缓存可以无限增长。可以使用 WeakMap 来解决此问题。它是一种具有弱键引用的数据结构，仅接受对象作为键。如果我们使用一个对象作为键，并且它是对该对象的唯一引用——相关变量将从缓存中删除并被垃圾收集。

### for...in 和 for...of 的区别

- `for in` 遍历的是数组的索引（或对象的键名）； `for of` 遍历的是数组元素值
- `for in` 会遍历数组/对象的原型上的可枚举属性，可以使用 `hasOwnProperty()` 方法将遍历限制在数组/对象内
- `for of` 的遍历不包括原型
- `for of` 适用遍历数组/字符串/`map`/`set` 等拥有迭代器对象（`iterator`）的集合，（*不能遍历对象，因为没有迭代器对象*）

### Symbol 有哪些使用场景？

- 作为对象属性的键名，避免键名冲突问题
	- Symbol 类型的 key 是不能通过 `Object.keys()` 或者 `for...in` 来枚举，利用该特性，我们可以把一些不需要对外操作和访问的属性使用 Symbol 来定义。
	- 要想访问以 Symbol 方式定义的对象属性，可以用 `Object.getOwnPropertySymbols(obj)` 或 `Reflect.ownKeys(obj)`
- 定义常量，避免命名冲突

### 内部对象的常用 API

[[JavaScript 常用方法]]

### WeakSet、WeakMap 和 Set、Map 区别？

**Set**

- 成员不能重复
- 只有健值，没有健名，有点类似数组。
- 可以遍历，方法有 add, delete,has

**WeakSet**

- 成员都是对象
- 成员都是弱引用，随时可以消失。 可以用来保存 DOM 节点，不容易造成内存泄漏
- 不能遍历，方法有 add, delete,has

**Map**

- 本质上是健值对的集合，类似集合
- 可以遍历，方法很多，可以干跟各种数据格式转换

**WeakMap**

- 直接受对象作为健名（null 除外），不接受其他类型的值作为健名
- 健名所指向的对象，不计入垃圾回收机制
- 不能遍历，方法有 get,set,has,delete

### 简述 Object.defineProperty

`Object.defineProperty` 可更为精确的定义对象属性

```js
const o = {};
Object.defineProperty(o, "a", {
  configurable: false, // 是否可被删除
  enumerable: false, // 是否可被枚举
  writable: true, // 是否可更改该属性值
  value: 3, // 该属性的值
  // 拦截该属性的读写
  get() {
    return this._a;
  },
  set(a) {
    this._a = a * 10;
  },
});
```

### Object.keys 与 Object.getOwnPropertyNames() 有何区别？

- `Object.keys`: 列出对象自身可枚举的属性值
- `Object.getOwnPropertyNames`: 列出对象自身所有属性值 (包括可枚举与不可枚举)

### 为何 0.1+0.2 不等于 0.3，应如何做相等比较?

0.1，0.2 表示为二进制会有精度的损失，比较时可引入一个很小的数值 `Number.EPSILON` 容忍误差，其值为 2^-52。

```js
function equal(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}
```

### 说说你有什么办法把数组去重？

1. filter 过滤配合 indexOf
2. `[...new Set(arr)]`
3. 新建数组，遍历原数组，利用 includes 去重
4. 先用 sort 排序，然后每一项与上一项相同就删除

### 可迭代对象有哪些特点？

ES6 规定，默认的 `Iterator` 接口部署在数据结构的 `Symbol.iterator` 属性，换个角度，也可以认为，一个数据结构只要具有 `Symbol.iterator` 属性 (`Symbol.iterator` 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。

可迭代对象的特点：

- 具有 Symbol.iterator 属性，Symbol.iterator() 返回的是一个遍历器对象
- 可以使用 for ... of 进行循环
- 通过被 Array.from 转换为数组

原生具有 Iterator 接口的数据结构：

- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象

### 平常工作中 ES6+ 主要用到了哪些？

ES6：

- Class
- 模块 import 和 export
- 箭头函数
- 函数默认参数
- `...` 扩展运算符允许展开数组
- 解构
- 字符串模版
- Promise
- let const
- Proxy、Map、Set
- 对象属性同名能简写

ES7：

- includes
- `**` 求幂运算符

ES8：

- async/await
- Object.values() 和 Object.entries()
- padStart() 和 padEnd()
- Object.getOwnPropertyDescriptors()
- 函数参数允许尾部

ES9：

- for...await...of
- `...` 展开符合允许展开对象收集剩余参数
- Promise.finally()
- 正则中的四个新功能

ES10：

- flat()
- flatMap()
- fromEntries()
- trimStart 和 trimEnd
- matchAll
- BigInt
- try/catch 中报错允许没有 err 异常参数
- Symbol.prototype.description
- Function.toString() 调用时呈现原本源码的样子

### js 定时器为什么是不精确的?

JavaScript 中的定时器（`setTimeout` 和 `setInterval`）也可能不是完全精确的，这是因为 JavaScript 是单线程的，并且在执行 JavaScript 代码时，可能会发生以下情况导致定时器不精确：

1. 事件循环机制：
    - JavaScript 使用事件循环机制来处理异步任务。当定时器到期时，会将定时器的回调函数放入任务队列中，等待执行。但是，只有在主线程上的执行栈为空时，才会从任务队列中取出任务执行。因此，如果在定时器到期时主线程正在执行其他任务，定时器的回调函数可能会延迟执行。
2. 高优先级任务：
    - 如果在定时器到期前有其他高优先级的任务需要执行，例如用户交互事件或网络请求，JavaScript 引擎会优先处理这些任务。这可能会导致定时器的回调函数被延迟执行。
3. 定时器的最小延迟：
    - 根据 HTML5 规范，`setTimeout` 和 `setInterval` 的最小延迟时间是 4 毫秒。这意味着无论传递给定时器的延迟值是多少，实际上定时器最早也会在 4 毫秒后执行。这种最小延迟的存在可能导致定时器的不精确性。
4. 页面不可见性：
    - 当页面处于不可见状态（例如，用户切换到其他标签或最小化浏览器窗口），浏览器可能会降低对定时器的处理优先级，以节省资源。这可能导致定时器的回调函数被延迟执行或甚至暂停执行。

要提高定时器的精确性，可以考虑以下方法：

- 使用 `requestAnimationFrame` 代替 `setTimeout` 或 `setInterval`，因为 `requestAnimationFrame` 会在浏览器的下一帧绘制之前执行，通常可以获得更好的时间精度。
- 使用 `Web Workers` 在后台线程中处理定时任务，以避免主线程的阻塞。
- 注意避免在定时器回调函数中执行耗时的操作，以确保定时器的回调函数能够及时执行。

尽管如此，仍然无法保证定时器的绝对精确性，因为它受到浏览器和操作系统等因素的限制。
