
### 语言特性

- **高级语言**：不需要手动管理内存等资源
- **垃圾回收**：从内存中自动删除旧的、未使用的对象
- **即时编译语言**：解析->编译->执行。首先生成未优化的机器代码立即执行，在执行过程中后台对代码进行优化并重新编译执行。
- **多范式**：过程式编程，面向对象编程，函数式编程
- **基于原型、面向对象**：JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。
- **头等函数**：函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量
- **动态类型/弱类型**：没有类型定义，类型在运行时确认，类型可以动态改变
- **单线程**：逐步执行，一次只做一件事
- **非阻塞/事件循环**：JavaScript在执行代码时，会将同步的代码按照顺序排在执行栈中，然后依次执行里面的函数。当遇到异步任务时，就将其放入任务队列中，等待当前执行栈所有同步代码执行完成之后，就会从异步任务队列中取出已完成的异步任务的回调并将其放入执行栈中继续执行，如此循环往复，直到执行完所有任务。

### 执行上下文

每当 Javascript 代码在运行的时候，它都是在执行上下文中运行，执行上下文包含了执行代码需要的东西，包括变量环境，作用域链，this关键字。

- **全局执行上下文** — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 `this` 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
- **函数执行上下文** — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。

### JavaScript执行过程

1. 创建全局执行上下文
2. 执行顶层代码
3. 对于每个函数调用，创建对应的函数执行上下文并执行，等待回调

### 运行时

![[Pasted image 20231130150545.png]]

- 堆：存储对象。
- 执行栈：存储函数调用（执行上下文）的栈结构，遵循**先进后出**的原则。**它主要负责跟踪所有要执行的代码。**
- 任务队列：保存异步任务，遵循**先进先出**的原则。**它主要负责将新的任务发送到队列中进行处理。**

JavaScript在执行代码时，会将同步的代码按照顺序排在执行栈中，然后依次执行里面的函数。当遇到异步任务时，就将其放入任务队列中，等待当前执行栈所有同步代码执行完成之后，就会从异步任务队列中取出已完成的异步任务的回调并将其放入执行栈中继续执行，如此循环往复，直到执行完所有任务。

基本数据类型存储在执行栈中；引用数据类型（对象、数组、方法等）实际存储在堆中，仅在执行栈中保存引用地址。

![[Pasted image 20231201151524.png]]

### 作用域

- 全局作用域：定义在全局作用域的变量可以在任何地方访问
- 函数作用域：定义在函数作用域的变量只能在函数内部访问（在严格模式中，函数作用域也是块作用域）
- 块作用域：使用`let`和`const`关键字在块作用域中定义的变量只能在块作用域中访问
- 作用域链：内部作用域可以访问外部作用域中块作用域以外的变量。

### this 关键字

#### 函数上下文中的 this 指向

- 作为对象的方法被调用时，指向被访问的对象；
- 常规函数调用，this的值为undefined
- 箭头函数中，不会创建一个新的 `this` 绑定，保留了闭合词法上下文的 `this` 值。无论如何调用，`this` 都绑定到箭头函数创建时所在作用域的`this`值。
- 在事件监听函数中，指向回调绑定的dom对象
- 在构造函数中，指向正在构造的新对象上（除非构造函数返回另一个非原始值）
- 以 `super.method()` 的形式被调用时，`method` 函数内的 `this` 与 `super.method()` 调用周围的 `this` 值相同

#### 改变 this 指向

在常规函数调用时， this 总是为 undefined，有时候需要将它手动绑定到一个特定对象上来取值。

```js
const fn = function (greet) {
    console.log(`${greet},${this.name}`);
};

const person = {
    name: "tao",
};

// call
// 传入 this 绑定的对象和函数的参数
fn.call(person, "hello"); // hello,tao

// apply
// 传入 this 绑定的对象和函数的参数组成的数组
fn.apply(person, ["hello"]); // hello,tao
// 可以用 call 做到相同的事情
fn.call(person, ...["hello"]); // hello,tao

// bind
// 创建一个新函数并将this绑定到传入对象上
const fn2 = fn.bind(person);
fn2('hello');  // hello,tao
// 可以在绑定时设置参数
const fn3 = fn.bind(person, 'hello');
fn3() // hello,tao
// 作用1:给高阶函数传入方法
document.querySelector('div').addEventListener('click', fn.bind(person));
// 作用2:不管this指向，只指定参数
const fn4 = fn.bind(null, 'hello');

```

### 变量提升

变量提升是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。`var`声明的变量被提升后，会给变量设置默认值为 undefined。

如果区块中存在 let 和 const，这个区块对这两个关键字声明的变量，从一开始就形成了封闭作用域。假如尝试在声明前去使用这类变量，就会报错。这一段会报错的区域就是**暂时性死区**。

在编译阶段，JS 引擎会搜集所有的变量声明，并且提前让声明生效。

### 闭包

闭包是由函数以及声明该函数的词法环境（_词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。_）组合而成的，该环境包含了这个闭包**创建时**作用域内的任何**局部变量**。即使父函数已经执行结束，闭包使子函数依旧能访问到父函数中的局部变量。

闭包使函数可以访问其父函数的所有变量，即使在父函数返回之后也是如此。该函数保留对其外部作用域的引用，从而始终保留作用域链。

![[Pasted image 20231203144440.png]]

### 文档对象模型（DOM）

文档对象模型（DOM）是一个网络文档的**编程接口**。它代表页面，以便程序可以改变文档的结构、风格和内容。DOM 将文档表示为节点和对象；这样，编程语言就可以与页面交互。

位于文档中的每个对象都是某种类型的节点（**Node**）。在一个 HTML 文档中，一个对象可以是一个元素节点，也可以是一个文本节点或属性节点。`element` 类型是基于 `node` 的，`element` 对象实现了 DOM 的 `Element` 接口和更基本的 `Node` 接口。

![[Pasted image 20231205160700.png]]

### 事件

当有很多嵌套的元素，每个元素都有着自己的事件处理器，事件处理过程会变得非常复杂。尤其当一个父元素和子元素绑定完全相同的事件时，因为结构上的重叠，事件在技术层面发生在两个元素中，触发的顺序取决于每个处理器的[事件冒泡和事件捕获](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7)的设置。

**事件冒泡**：当某元素执行某一种类型事件，那么从该元素起逐级向外层的元素检测是否存在与本身同样的事件。这一个过程，就叫做事件冒泡。

**事件捕获**：当元素被触发事件时候，从该元素的根节点开始逐级向里寻找同类型事件。这个过程，就被称为事件捕获

**事件的流向有三个阶段：捕获阶段，目标阶段，冒泡阶段。** 当一个元素身上的事件被触发后，会优先从根节点进行事件捕获（捕获阶段），然后寻找到自身为止（目标阶段），最后从自身往外层逐级冒泡（冒泡阶段）。**事件冒泡和事件捕获本身并不会主动触发事件。需要我们决定事件在冒泡阶段执行还是在捕获阶段执行。**

**事件代理**：事件代理就是利用事件冒泡或事件捕获的机制把一系列的内层元素事件绑定到外层元素。（这也就意味着子元素本身将不用注册自己的事件）事件监听器中的 `e`（事件对象）表示**当前触发的事件**，所以即使事件在父元素中执行，`e.target`指向的还是触发事件的子元素。